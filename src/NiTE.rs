/* automatically generated by rust-bindgen 0.58.1 */

pub mod OpenNI;

use OpenNI::OniFrame;
use OpenNI::OniVideoMode;
use OpenNI::OniDeviceInfo;
use OpenNI::OniSensorInfo;
use OpenNI::oniFrameRelease;
use OpenNI::oniFrameAddRef;

use std::mem::MaybeUninit;

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const NITE_JOINT_COUNT: u32 = 15;
pub const NITE_POSE_COUNT: u32 = 2;
pub const NITE_VERSION_MAJOR: u32 = 2;
pub const NITE_VERSION_MINOR: u32 = 2;
pub const NITE_VERSION_MAINTENANCE: u32 = 0;
pub const NITE_VERSION_BUILD: u32 = 5;
pub const NITE_VERSION: u32 = 202000005;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type OniDeviceHandle = u64;
pub type OniGeneralCallback = u64;
pub const NiteJointType_NITE_JOINT_HEAD: NiteJointType = 0;
pub const NiteJointType_NITE_JOINT_NECK: NiteJointType = 1;
pub const NiteJointType_NITE_JOINT_LEFT_SHOULDER: NiteJointType = 2;
pub const NiteJointType_NITE_JOINT_RIGHT_SHOULDER: NiteJointType = 3;
pub const NiteJointType_NITE_JOINT_LEFT_ELBOW: NiteJointType = 4;
pub const NiteJointType_NITE_JOINT_RIGHT_ELBOW: NiteJointType = 5;
pub const NiteJointType_NITE_JOINT_LEFT_HAND: NiteJointType = 6;
pub const NiteJointType_NITE_JOINT_RIGHT_HAND: NiteJointType = 7;
pub const NiteJointType_NITE_JOINT_TORSO: NiteJointType = 8;
pub const NiteJointType_NITE_JOINT_LEFT_HIP: NiteJointType = 9;
pub const NiteJointType_NITE_JOINT_RIGHT_HIP: NiteJointType = 10;
pub const NiteJointType_NITE_JOINT_LEFT_KNEE: NiteJointType = 11;
pub const NiteJointType_NITE_JOINT_RIGHT_KNEE: NiteJointType = 12;
pub const NiteJointType_NITE_JOINT_LEFT_FOOT: NiteJointType = 13;
pub const NiteJointType_NITE_JOINT_RIGHT_FOOT: NiteJointType = 14;
#[doc = " Available joints in skeleton"]
pub type NiteJointType = ::std::os::raw::c_uint;
#[doc = " No skeleton - skeleton was not requested"]
pub const NiteSkeletonState_NITE_SKELETON_NONE: NiteSkeletonState = 0;
#[doc = " Skeleton requested, but still unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATING: NiteSkeletonState = 1;
#[doc = " Skeleton available"]
pub const NiteSkeletonState_NITE_SKELETON_TRACKED: NiteSkeletonState = 2;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_NOT_IN_POSE: NiteSkeletonState = 3;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_HANDS: NiteSkeletonState = 4;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_HEAD: NiteSkeletonState = 5;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_LEGS: NiteSkeletonState = 6;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_TORSO: NiteSkeletonState = 7;
#[doc = " Possible states of the skeleton"]
pub type NiteSkeletonState = ::std::os::raw::c_uint;
#[doc = " User is visible and already known"]
pub const NiteUserState_NITE_USER_STATE_VISIBLE: NiteUserState = 1;
#[doc = " User is new - this is the first time the user is available"]
pub const NiteUserState_NITE_USER_STATE_NEW: NiteUserState = 2;
#[doc = " User is lost. This is the last time this user will be seen"]
pub const NiteUserState_NITE_USER_STATE_LOST: NiteUserState = 4;
#[doc = " Possible states of the user"]
pub type NiteUserState = ::std::os::raw::c_uint;
pub const NiteStatus_NITE_STATUS_OK: NiteStatus = 0;
pub const NiteStatus_NITE_STATUS_ERROR: NiteStatus = 1;
pub const NiteStatus_NITE_STATUS_BAD_USER_ID: NiteStatus = 2;
pub const NiteStatus_NITE_STATUS_OUT_OF_FLOW: NiteStatus = 3;
#[doc = " Possible failure values"]
pub type NiteStatus = ::std::os::raw::c_uint;
pub const NitePoseType_NITE_POSE_PSI: NitePoseType = 0;
pub const NitePoseType_NITE_POSE_CROSSED_HANDS: NitePoseType = 1;
pub type NitePoseType = ::std::os::raw::c_uint;
pub const NitePoseState_NITE_POSE_STATE_DETECTING: NitePoseState = 1;
pub const NitePoseState_NITE_POSE_STATE_IN_POSE: NitePoseState = 2;
pub const NitePoseState_NITE_POSE_STATE_ENTER: NitePoseState = 4;
pub const NitePoseState_NITE_POSE_STATE_EXIT: NitePoseState = 8;
pub type NitePoseState = ::std::os::raw::c_uint;
pub const NiteGestureType_NITE_GESTURE_WAVE: NiteGestureType = 0;
pub const NiteGestureType_NITE_GESTURE_CLICK: NiteGestureType = 1;
pub const NiteGestureType_NITE_GESTURE_HAND_RAISE: NiteGestureType = 2;
#[doc = " Available gestures types"]
pub type NiteGestureType = ::std::os::raw::c_uint;
pub const NiteGestureState_NITE_GESTURE_STATE_NEW: NiteGestureState = 1;
pub const NiteGestureState_NITE_GESTURE_STATE_IN_PROGRESS: NiteGestureState = 2;
pub const NiteGestureState_NITE_GESTURE_STATE_COMPLETED: NiteGestureState = 4;
#[doc = " Possible state of a gesture. Currently only 'Complete' is used."]
pub type NiteGestureState = ::std::os::raw::c_uint;
#[doc = " This hand was lost. It is the last frame in which it will be provided"]
pub const NiteHandState_NITE_HAND_STATE_LOST: NiteHandState = 0;
#[doc = " This is a new hand - it is the first frame in which it is available"]
pub const NiteHandState_NITE_HAND_STATE_NEW: NiteHandState = 1;
#[doc = " This is a known hand"]
pub const NiteHandState_NITE_HAND_STATE_TRACKED: NiteHandState = 2;
#[doc = " This is a known hand, and in this frame it's very near the edge of the field of view"]
pub const NiteHandState_NITE_HAND_STATE_TOUCHING_FOV: NiteHandState = 4;
#[doc = " Possible state of a hand"]
pub type NiteHandState = ::std::os::raw::c_uint;
pub type NiteUserId = ::std::os::raw::c_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserTracker {
    _unused: [u8; 0],
}
pub type NiteUserTrackerHandle = *mut NiteUserTracker;
#[doc = " 3D Point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NitePoint3f {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_NitePoint3f() {
    assert_eq!(
        ::std::mem::size_of::<NitePoint3f>(),
        12usize,
        concat!("Size of: ", stringify!(NitePoint3f))
    );
    assert_eq!(
        ::std::mem::align_of::<NitePoint3f>(),
        4usize,
        concat!("Alignment of ", stringify!(NitePoint3f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoint3f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoint3f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoint3f>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoint3f),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoint3f>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoint3f),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " Quaternion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteQuaternion {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_NiteQuaternion() {
    assert_eq!(
        ::std::mem::size_of::<NiteQuaternion>(),
        16usize,
        concat!("Size of: ", stringify!(NiteQuaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteQuaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteQuaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " Single joint of a skeleton"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteSkeletonJoint {
    #[doc = " Type of the joint"]
    pub jointType: NiteJointType,
    #[doc = " Position of the joint - in real world coordinates"]
    pub position: NitePoint3f,
    pub positionConfidence: f32,
    #[doc = " Orientation of the joint"]
    pub orientation: NiteQuaternion,
    pub orientationConfidence: f32,
}
#[test]
fn bindgen_test_layout_NiteSkeletonJoint() {
    assert_eq!(
        ::std::mem::size_of::<NiteSkeletonJoint>(),
        40usize,
        concat!("Size of: ", stringify!(NiteSkeletonJoint))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteSkeletonJoint>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteSkeletonJoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeletonJoint>())).jointType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(jointType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeletonJoint>())).position as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteSkeletonJoint>())).positionConfidence as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(positionConfidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeletonJoint>())).orientation as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteSkeletonJoint>())).orientationConfidence as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(orientationConfidence)
        )
    );
}
#[doc = " 3D Box"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteBoundingBox {
    pub min: NitePoint3f,
    pub max: NitePoint3f,
}
#[test]
fn bindgen_test_layout_NiteBoundingBox() {
    assert_eq!(
        ::std::mem::size_of::<NiteBoundingBox>(),
        24usize,
        concat!("Size of: ", stringify!(NiteBoundingBox))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteBoundingBox>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteBoundingBox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteBoundingBox>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteBoundingBox),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteBoundingBox>())).max as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteBoundingBox),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NitePoseData {
    pub type_: NitePoseType,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NitePoseData() {
    assert_eq!(
        ::std::mem::size_of::<NitePoseData>(),
        8usize,
        concat!("Size of: ", stringify!(NitePoseData))
    );
    assert_eq!(
        ::std::mem::align_of::<NitePoseData>(),
        4usize,
        concat!("Alignment of ", stringify!(NitePoseData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoseData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoseData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoseData>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoseData),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Skeleton - a set of joints"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteSkeleton {
    pub joints: [NiteSkeletonJoint; 15usize],
    pub state: NiteSkeletonState,
}
#[test]
fn bindgen_test_layout_NiteSkeleton() {
    assert_eq!(
        ::std::mem::size_of::<NiteSkeleton>(),
        604usize,
        concat!("Size of: ", stringify!(NiteSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteSkeleton>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteSkeleton))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeleton>())).joints as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeleton),
            "::",
            stringify!(joints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeleton>())).state as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeleton),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Snapshot of a specific user"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserData {
    pub id: NiteUserId,
    pub boundingBox: NiteBoundingBox,
    pub centerOfMass: NitePoint3f,
    pub state: ::std::os::raw::c_int,
    pub skeleton: NiteSkeleton,
    pub poses: [NitePoseData; 2usize],
}
#[test]
fn bindgen_test_layout_NiteUserData() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserData>(),
        664usize,
        concat!("Size of: ", stringify!(NiteUserData))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserData>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteUserData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).boundingBox as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(boundingBox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).centerOfMass as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(centerOfMass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).skeleton as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(skeleton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).poses as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(poses)
        )
    );
}
#[doc = " Snapshot of the scene segmentation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserMap {
    pub pixels: *mut NiteUserId,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub stride: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteUserMap() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserMap>(),
        24usize,
        concat!("Size of: ", stringify!(NiteUserMap))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserMap>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteUserMap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).pixels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).stride as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(stride)
        )
    );
}
#[doc = " 3D Plane"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NitePlane {
    pub point: NitePoint3f,
    pub normal: NitePoint3f,
}
#[test]
fn bindgen_test_layout_NitePlane() {
    assert_eq!(
        ::std::mem::size_of::<NitePlane>(),
        24usize,
        concat!("Size of: ", stringify!(NitePlane))
    );
    assert_eq!(
        ::std::mem::align_of::<NitePlane>(),
        4usize,
        concat!("Alignment of ", stringify!(NitePlane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePlane>())).point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePlane),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePlane>())).normal as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePlane),
            "::",
            stringify!(normal)
        )
    );
}
#[doc = " Output snapshot of the User Tracker algorithm"]
#[repr(C)]
#[derive(Debug)]
pub struct NiteUserTrackerFrame {
    #[doc = " Number of users"]
    pub userCount: ::std::os::raw::c_int,
    #[doc = " Scene segmentation map"]
    pub userMap: NiteUserMap,
    #[doc = " The depth frame from which this data was learned"]
    pub pDepthFrame: *mut OniFrame,
    pub timestamp: ::std::os::raw::c_ulonglong,
    pub frameIndex: ::std::os::raw::c_int,
    #[doc = " Confidence of the floor plane"]
    pub floorConfidence: f32,
    #[doc = " Floor plane"]
    pub floor: NitePlane,
    pub pUser: __IncompleteArrayField<NiteUserData>,
}
#[test]
fn bindgen_test_layout_NiteUserTrackerFrame() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserTrackerFrame>(),
        80usize,
        concat!("Size of: ", stringify!(NiteUserTrackerFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserTrackerFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteUserTrackerFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).userCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(userCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).userMap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(userMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteUserTrackerFrame>())).pDepthFrame as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(pDepthFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).timestamp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).frameIndex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(frameIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteUserTrackerFrame>())).floorConfidence as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(floorConfidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).floor as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(floor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).pUser as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(pUser)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserTrackerCallbacks {
    pub readyForNextFrame: OniGeneralCallback,
}
#[test]
fn bindgen_test_layout_NiteUserTrackerCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserTrackerCallbacks>(),
        8usize,
        concat!("Size of: ", stringify!(NiteUserTrackerCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserTrackerCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteUserTrackerCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteUserTrackerCallbacks>())).readyForNextFrame as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerCallbacks),
            "::",
            stringify!(readyForNextFrame)
        )
    );
}
pub type NiteHandId = ::std::os::raw::c_short;
#[doc = " A snapshot of a specific hand"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandData {
    pub id: NiteHandId,
    pub position: NitePoint3f,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteHandData() {
    assert_eq!(
        ::std::mem::size_of::<NiteHandData>(),
        20usize,
        concat!("Size of: ", stringify!(NiteHandData))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteHandData>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteHandData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandData>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandData>())).position as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandData),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandData>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandData),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " A snapshot of a specific gesture"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteGestureData {
    pub type_: NiteGestureType,
    pub currentPosition: NitePoint3f,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteGestureData() {
    assert_eq!(
        ::std::mem::size_of::<NiteGestureData>(),
        20usize,
        concat!("Size of: ", stringify!(NiteGestureData))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteGestureData>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteGestureData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteGestureData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteGestureData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteGestureData>())).currentPosition as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteGestureData),
            "::",
            stringify!(currentPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteGestureData>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteGestureData),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Output snapshot of the Hand Tracker algorithm"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandTrackerFrame {
    #[doc = " Number of hands"]
    pub handCount: ::std::os::raw::c_int,
    #[doc = " List of hands"]
    pub pHands: *mut NiteHandData,
    #[doc = " Number of gestures"]
    pub gestureCount: ::std::os::raw::c_int,
    #[doc = " List of gestures"]
    pub pGestures: *mut NiteGestureData,
    #[doc = " The depth frame from which this data was learned"]
    pub pDepthFrame: *mut OniFrame,
    pub timestamp: ::std::os::raw::c_ulonglong,
    pub frameIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteHandTrackerFrame() {
    assert_eq!(
        ::std::mem::size_of::<NiteHandTrackerFrame>(),
        56usize,
        concat!("Size of: ", stringify!(NiteHandTrackerFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteHandTrackerFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteHandTrackerFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).handCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(handCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).pHands as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(pHands)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteHandTrackerFrame>())).gestureCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(gestureCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).pGestures as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(pGestures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteHandTrackerFrame>())).pDepthFrame as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(pDepthFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).timestamp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).frameIndex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(frameIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandTrackerCallbacks {
    pub readyForNextFrame: OniGeneralCallback,
}
#[test]
fn bindgen_test_layout_NiteHandTrackerCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<NiteHandTrackerCallbacks>(),
        8usize,
        concat!("Size of: ", stringify!(NiteHandTrackerCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteHandTrackerCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteHandTrackerCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteHandTrackerCallbacks>())).readyForNextFrame as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerCallbacks),
            "::",
            stringify!(readyForNextFrame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteVersion {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub maintenance: ::std::os::raw::c_int,
    pub build: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteVersion() {
    assert_eq!(
        ::std::mem::size_of::<NiteVersion>(),
        16usize,
        concat!("Size of: ", stringify!(NiteVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).maintenance as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(maintenance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).build as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(build)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandTracker {
    _unused: [u8; 0],
}
pub type NiteHandTrackerHandle = *mut NiteHandTracker;
extern "C" {
    pub fn niteInitialize() -> NiteStatus;
}
extern "C" {
    pub fn niteShutdown();
}
extern "C" {
    pub fn niteGetVersion() -> NiteVersion;
}
extern "C" {
    pub fn niteInitializeUserTracker(arg1: *mut NiteUserTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteInitializeUserTrackerByDevice(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut NiteUserTrackerHandle,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteShutdownUserTracker(arg1: NiteUserTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteStartSkeletonTracking(arg1: NiteUserTrackerHandle, arg2: NiteUserId) -> NiteStatus;
}
extern "C" {
    pub fn niteStopSkeletonTracking(arg1: NiteUserTrackerHandle, arg2: NiteUserId);
}
extern "C" {
    pub fn niteIsSkeletonTracking(arg1: NiteUserTrackerHandle, arg2: NiteUserId) -> bool;
}
extern "C" {
    pub fn niteSetSkeletonSmoothing(arg1: NiteUserTrackerHandle, arg2: f32) -> NiteStatus;
}
extern "C" {
    pub fn niteGetSkeletonSmoothing(arg1: NiteUserTrackerHandle, arg2: *mut f32) -> NiteStatus;
}
extern "C" {
    pub fn niteStartPoseDetection(
        arg1: NiteUserTrackerHandle,
        arg2: NiteUserId,
        arg3: NitePoseType,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStopPoseDetection(arg1: NiteUserTrackerHandle, arg2: NiteUserId, arg3: NitePoseType);
}
extern "C" {
    pub fn niteStopAllPoseDetection(arg1: NiteUserTrackerHandle, arg2: NiteUserId);
}
extern "C" {
    pub fn niteRegisterUserTrackerCallbacks(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerCallbacks,
        arg3: *mut ::std::os::raw::c_void,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUnregisterUserTrackerCallbacks(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerCallbacks,
    );
}
extern "C" {
    pub fn niteReadUserTrackerFrame(
        arg1: NiteUserTrackerHandle,
        arg2: *mut *mut NiteUserTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUserTrackerFrameAddRef(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUserTrackerFrameRelease(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteInitializeHandTracker(arg1: *mut NiteHandTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteInitializeHandTrackerByDevice(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut NiteHandTrackerHandle,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteShutdownHandTracker(arg1: NiteHandTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteStartHandTracking(
        arg1: NiteHandTrackerHandle,
        arg2: *const NitePoint3f,
        pNewHandId: *mut NiteHandId,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStopHandTracking(arg1: NiteHandTrackerHandle, arg2: NiteHandId);
}
extern "C" {
    pub fn niteStopAllHandTracking(arg1: NiteHandTrackerHandle);
}
extern "C" {
    pub fn niteSetHandSmoothingFactor(arg1: NiteHandTrackerHandle, arg2: f32) -> NiteStatus;
}
extern "C" {
    pub fn niteGetHandSmoothingFactor(arg1: NiteHandTrackerHandle, arg2: *mut f32) -> NiteStatus;
}
extern "C" {
    pub fn niteRegisterHandTrackerCallbacks(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerCallbacks,
        arg3: *mut ::std::os::raw::c_void,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUnregisterHandTrackerCallbacks(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerCallbacks,
    );
}
extern "C" {
    pub fn niteReadHandTrackerFrame(
        arg1: NiteHandTrackerHandle,
        arg2: *mut *mut NiteHandTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteHandTrackerFrameAddRef(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteHandTrackerFrameRelease(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStartGestureDetection(
        arg1: NiteHandTrackerHandle,
        arg2: NiteGestureType,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStopGestureDetection(arg1: NiteHandTrackerHandle, arg2: NiteGestureType);
}
extern "C" {
    pub fn niteStopAllGestureDetection(arg1: NiteHandTrackerHandle);
}
extern "C" {
    pub fn niteConvertJointCoordinatesToDepth(
        userTracker: NiteUserTrackerHandle,
        x: f32,
        y: f32,
        z: f32,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteConvertDepthCoordinatesToJoint(
        userTracker: NiteUserTrackerHandle,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteConvertHandCoordinatesToDepth(
        handTracker: NiteHandTrackerHandle,
        x: f32,
        y: f32,
        z: f32,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteConvertDepthCoordinatesToHand(
        handTracker: NiteHandTrackerHandle,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}
#[doc = "Provides a simple array class used throughout the API. Wraps a primitive array"]
#[doc = "of objects, holding the elements and their count."]
#[repr(C)]
#[derive(Debug)]
pub struct openni_Array<T> {
    pub m_data: *const T,
    pub m_count: ::std::os::raw::c_int,
    pub m_owner: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = "Encapsulates a group of settings for a @ref VideoStream.  Settings stored include"]
#[doc = "frame rate, resolution, and pixel format."]
#[doc = ""]
#[doc = "This class is used as an input for changing the settings of a @ref VideoStream,"]
#[doc = "as well as an output for reporting the current settings of that class.  It is also used"]
#[doc = "by @ref SensorInfo to report available video modes of a stream."]
#[doc = ""]
#[doc = "Recommended practice is to use @ref SensorInfo::getSupportedVideoModes()"]
#[doc = "to obtain a list of valid video modes, and then to use items from that list to pass"]
#[doc = "new settings to @ref VideoStream.  This is much less likely to produce an"]
#[doc = "invalid video mode than instantiating and manually changing objects of this"]
#[doc = "class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openni_VideoMode {
    pub _base: OniVideoMode,
}
#[test]
fn bindgen_test_layout_openni_VideoMode() {
    assert_eq!(
        ::std::mem::size_of::<openni_VideoMode>(),
        16usize,
        concat!("Size of: ", stringify!(openni_VideoMode))
    );
    assert_eq!(
        ::std::mem::align_of::<openni_VideoMode>(),
        4usize,
        concat!("Alignment of ", stringify!(openni_VideoMode))
    );
}
#[doc = "The SensorInfo class encapsulates all info related to a specific sensor in a specific"]
#[doc = "device."]
#[doc = "A @ref Device object holds a SensorInfo object for each sensor it contains."]
#[doc = "A @ref VideoStream object holds one SensorInfo object, describing the sensor used to produce that stream."]
#[doc = ""]
#[doc = "A given SensorInfo object will contain the type of the sensor (Depth, IR or Color), and"]
#[doc = "a list of all video modes that the sensor can support.  Each available video mode will have a single"]
#[doc = "VideoMode object that can be queried to get the details of that mode."]
#[doc = ""]
#[doc = "SensorInfo objects should be the only source of VideoMode objects for the vast majority of"]
#[doc = "application programs."]
#[doc = ""]
#[doc = "Application programs will never directly instantiate objects of type SensorInfo.  In fact, no"]
#[doc = "public constructors are provided.  SensorInfo objects should be obtained either from a Device or @ref VideoStream,"]
#[doc = "and in turn be used to provide available video modes for that sensor."]
#[repr(C)]
#[derive(Debug)]
pub struct openni_SensorInfo {
    pub m_pInfo: *const OniSensorInfo,
    pub m_videoModes: openni_Array<openni_VideoMode>,
}
#[test]
fn bindgen_test_layout_openni_SensorInfo() {
    assert_eq!(
        ::std::mem::size_of::<openni_SensorInfo>(),
        24usize,
        concat!("Size of: ", stringify!(openni_SensorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<openni_SensorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(openni_SensorInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openni_SensorInfo>())).m_pInfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_SensorInfo),
            "::",
            stringify!(m_pInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openni_SensorInfo>())).m_videoModes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_SensorInfo),
            "::",
            stringify!(m_videoModes)
        )
    );
}
#[doc = "The DeviceInfo class encapsulates info related to a specific device."]
#[doc = ""]
#[doc = "Applications will generally obtain objects of this type via calls to @ref OpenNI::enumerateDevices() or"]
#[doc = "@ref openni::Device::getDeviceInfo(), and then use the various accessor functions to obtain specific"]
#[doc = "information on that device."]
#[doc = ""]
#[doc = "There should be no reason for application code to instantiate this object directly."]
#[repr(C)]
pub struct openni_DeviceInfo {
    pub _base: OniDeviceInfo,
}
#[test]
fn bindgen_test_layout_openni_DeviceInfo() {
    assert_eq!(
        ::std::mem::size_of::<openni_DeviceInfo>(),
        772usize,
        concat!("Size of: ", stringify!(openni_DeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<openni_DeviceInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(openni_DeviceInfo))
    );
}
#[doc = "The @ref VideoFrameRef class encapsulates a single video frame - the output of a @ref VideoStream at a specific time."]
#[doc = "The data contained will be a single frame of color, IR, or depth video, along with associated meta data."]
#[doc = ""]
#[doc = "An object of type @ref VideoFrameRef does not actually hold the data of the frame, but only a reference to it. The"]
#[doc = "reference can be released by destroying the @ref VideoFrameRef object, or by calling the @ref release() method. The"]
#[doc = "actual data of the frame is freed when the last reference to it is released."]
#[doc = ""]
#[doc = "The usual way to obtain @ref VideoFrameRef objects is by a call to @ref VideoStream.:readFrame()."]
#[doc = ""]
#[doc = "All data references by a @ref VideoFrameRef is stored as a primitive array of pixels.  Each pixel will be"]
#[doc = "of a type according to the configured pixel format (see @ref VideoMode)."]
#[repr(C)]
#[derive(Debug)]
pub struct openni_VideoFrameRef {
    pub m_pFrame: *mut OniFrame,
}

impl openni_VideoFrameRef {
    pub fn _setFrame(&mut self, pFrame: *mut OniFrame){
        self.setReference(pFrame);
        if (std::ptr::null() != pFrame){
            unsafe {oniFrameAddRef(pFrame)}
        }
    }

    pub fn release(&mut self){
        if (std::ptr::null() != self.m_pFrame){
            unsafe {oniFrameRelease(self.m_pFrame)};
        }
    }

    fn setReference(&mut self, pFrame: *mut OniFrame){
        self.release();
        self.m_pFrame = pFrame;
    }
}

#[test]
fn bindgen_test_layout_openni_VideoFrameRef() {
    assert_eq!(
        ::std::mem::size_of::<openni_VideoFrameRef>(),
        8usize,
        concat!("Size of: ", stringify!(openni_VideoFrameRef))
    );
    assert_eq!(
        ::std::mem::align_of::<openni_VideoFrameRef>(),
        8usize,
        concat!("Alignment of ", stringify!(openni_VideoFrameRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openni_VideoFrameRef>())).m_pFrame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_VideoFrameRef),
            "::",
            stringify!(m_pFrame)
        )
    );
}
#[doc = "The Device object abstracts a specific device; either a single hardware device, or a file"]
#[doc = "device holding a recording from a hardware device.  It offers the ability to connect to"]
#[doc = "the device, and obtain information about its configuration and the data streams it can offer."]
#[doc = ""]
#[doc = "It provides the means to query and change all configuration parameters that apply to the"]
#[doc = "device as a whole.  This includes enabling depth/color image registration and frame"]
#[doc = "synchronization."]
#[doc = ""]
#[doc = "Devices are used when creating and initializing @ref VideoStream \"VideoStreams\" -- you will need a valid pointer to"]
#[doc = "a Device in order to use the VideoStream.create() function.  This, along with configuration, is"]
#[doc = "the primary use of this class for application developers."]
#[doc = ""]
#[doc = "Before devices can be created, @ref OpenNI::initialize() must have been run to make the device drivers"]
#[doc = "on the system available to the API."]
#[repr(C)]
pub struct openni_Device {
    pub m_pPlaybackControl: *mut openni_PlaybackControl,
    pub m_device: OniDeviceHandle,
    pub m_deviceInfo: openni_DeviceInfo,
    pub m_aSensorInfo: [openni_SensorInfo; 10usize],
    pub m_isOwner: bool,
}
#[test]
fn bindgen_test_layout_openni_Device() {
    assert_eq!(
        ::std::mem::size_of::<openni_Device>(),
        1040usize,
        concat!("Size of: ", stringify!(openni_Device))
    );
    assert_eq!(
        ::std::mem::align_of::<openni_Device>(),
        8usize,
        concat!("Alignment of ", stringify!(openni_Device))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<openni_Device>())).m_pPlaybackControl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_Device),
            "::",
            stringify!(m_pPlaybackControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openni_Device>())).m_device as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_Device),
            "::",
            stringify!(m_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openni_Device>())).m_deviceInfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_Device),
            "::",
            stringify!(m_deviceInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openni_Device>())).m_aSensorInfo as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_Device),
            "::",
            stringify!(m_aSensorInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<openni_Device>())).m_isOwner as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_Device),
            "::",
            stringify!(m_isOwner)
        )
    );
}
#[doc = " The PlaybackControl class provides access to a series of specific to playing back"]
#[doc = " a recording from a file device."]
#[doc = ""]
#[doc = " When playing a stream back from a recording instead of playing from a live device,"]
#[doc = " it is possible to vary playback speed, change the current time location (ie"]
#[doc = " fast forward / rewind / seek), specify whether the playback should be repeated at the end"]
#[doc = " of the recording, and query the total size of the recording."]
#[doc = ""]
#[doc = " Since none of these functions make sense in the context of a physical device, they are"]
#[doc = " split out into a seperate playback control class.  To use, simply create your file device,"]
#[doc = " create a PlaybackControl, and then attach the PlaybackControl to the file device."]
#[repr(C)]
#[derive(Debug)]
pub struct openni_PlaybackControl {
    pub m_pDevice: *mut openni_Device,
}
#[test]
fn bindgen_test_layout_openni_PlaybackControl() {
    assert_eq!(
        ::std::mem::size_of::<openni_PlaybackControl>(),
        8usize,
        concat!("Size of: ", stringify!(openni_PlaybackControl))
    );
    assert_eq!(
        ::std::mem::align_of::<openni_PlaybackControl>(),
        8usize,
        concat!("Alignment of ", stringify!(openni_PlaybackControl))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<openni_PlaybackControl>())).m_pDevice as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(openni_PlaybackControl),
            "::",
            stringify!(m_pDevice)
        )
    );
}
pub const nite_JointType_JOINT_HEAD: nite_JointType = 0;
pub const nite_JointType_JOINT_NECK: nite_JointType = 1;
pub const nite_JointType_JOINT_LEFT_SHOULDER: nite_JointType = 2;
pub const nite_JointType_JOINT_RIGHT_SHOULDER: nite_JointType = 3;
pub const nite_JointType_JOINT_LEFT_ELBOW: nite_JointType = 4;
pub const nite_JointType_JOINT_RIGHT_ELBOW: nite_JointType = 5;
pub const nite_JointType_JOINT_LEFT_HAND: nite_JointType = 6;
pub const nite_JointType_JOINT_RIGHT_HAND: nite_JointType = 7;
pub const nite_JointType_JOINT_TORSO: nite_JointType = 8;
pub const nite_JointType_JOINT_LEFT_HIP: nite_JointType = 9;
pub const nite_JointType_JOINT_RIGHT_HIP: nite_JointType = 10;
pub const nite_JointType_JOINT_LEFT_KNEE: nite_JointType = 11;
pub const nite_JointType_JOINT_RIGHT_KNEE: nite_JointType = 12;
pub const nite_JointType_JOINT_LEFT_FOOT: nite_JointType = 13;
pub const nite_JointType_JOINT_RIGHT_FOOT: nite_JointType = 14;
#[doc = " Available joints in skeleton"]
pub type nite_JointType = ::std::os::raw::c_uint;
#[doc = " No skeleton - skeleton was not requested"]
pub const nite_SkeletonState_SKELETON_NONE: nite_SkeletonState = 0;
#[doc = " Skeleton requested, but still unavailable"]
pub const nite_SkeletonState_SKELETON_CALIBRATING: nite_SkeletonState = 1;
#[doc = " Skeleton available"]
pub const nite_SkeletonState_SKELETON_TRACKED: nite_SkeletonState = 2;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const nite_SkeletonState_SKELETON_CALIBRATION_ERROR_NOT_IN_POSE: nite_SkeletonState = 3;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const nite_SkeletonState_SKELETON_CALIBRATION_ERROR_HANDS: nite_SkeletonState = 4;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const nite_SkeletonState_SKELETON_CALIBRATION_ERROR_HEAD: nite_SkeletonState = 5;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const nite_SkeletonState_SKELETON_CALIBRATION_ERROR_LEGS: nite_SkeletonState = 6;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const nite_SkeletonState_SKELETON_CALIBRATION_ERROR_TORSO: nite_SkeletonState = 7;
#[doc = " Possible states of the skeleton"]
pub type nite_SkeletonState = ::std::os::raw::c_uint;
pub const nite_Status_STATUS_OK: nite_Status = 0;
pub const nite_Status_STATUS_ERROR: nite_Status = 1;
pub const nite_Status_STATUS_BAD_USER_ID: nite_Status = 2;
pub const nite_Status_STATUS_OUT_OF_FLOW: nite_Status = 3;
#[doc = " Possible failure values"]
pub type nite_Status = ::std::os::raw::c_uint;
pub const nite_PoseType_POSE_PSI: nite_PoseType = 0;
pub const nite_PoseType_POSE_CROSSED_HANDS: nite_PoseType = 1;
pub type nite_PoseType = ::std::os::raw::c_uint;
pub const nite_GestureType_GESTURE_WAVE: nite_GestureType = 0;
pub const nite_GestureType_GESTURE_CLICK: nite_GestureType = 1;
pub const nite_GestureType_GESTURE_HAND_RAISE: nite_GestureType = 2;
#[doc = " Available gestures types"]
pub type nite_GestureType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_Version {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub maintenance: ::std::os::raw::c_int,
    pub build: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nite_Version() {
    assert_eq!(
        ::std::mem::size_of::<nite_Version>(),
        16usize,
        concat!("Size of: ", stringify!(nite_Version))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Version>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_Version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nite_Version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_Version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nite_Version>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_Version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nite_Version>())).maintenance as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_Version),
            "::",
            stringify!(maintenance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nite_Version>())).build as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_Version),
            "::",
            stringify!(build)
        )
    );
}
#[doc = "Encapsulates a single point in 3D space, storing the x/y/z coordinates as floating point numbers."]
#[doc = ""]
#[doc = "Can also be used to represent a three dimensional vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_Point3f {
    pub _base: NitePoint3f,
}
#[test]
fn bindgen_test_layout_nite_Point3f() {
    assert_eq!(
        ::std::mem::size_of::<nite_Point3f>(),
        12usize,
        concat!("Size of: ", stringify!(nite_Point3f))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Point3f>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_Point3f))
    );
}
#[doc = "Enapsulates a geometrical plane.  The plane is defined by a single point on that plane, and a normal vector to the plane."]
#[doc = "The normal vector is represented as a Point3f."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_Plane {
    pub _base: NitePlane,
}
#[test]
fn bindgen_test_layout_nite_Plane() {
    assert_eq!(
        ::std::mem::size_of::<nite_Plane>(),
        24usize,
        concat!("Size of: ", stringify!(nite_Plane))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Plane>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_Plane))
    );
}
#[doc = "Represents a Quaternion.  The Quaternion is stored as four floating point numbers.  (The quaternions"]
#[doc = "are a number system that extends the complex number system from two dimensions to four.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_Quaternion {
    pub _base: NiteQuaternion,
}
#[test]
fn bindgen_test_layout_nite_Quaternion() {
    assert_eq!(
        ::std::mem::size_of::<nite_Quaternion>(),
        16usize,
        concat!("Size of: ", stringify!(nite_Quaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Quaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_Quaternion))
    );
}
#[doc = "Represents a box in three dimensional space.  The box is represented as two points,"]
#[doc = "containing respectively its minimum and maximum x, y and z coordinate values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_BoundingBox {
    pub _base: NiteBoundingBox,
}
#[test]
fn bindgen_test_layout_nite_BoundingBox() {
    assert_eq!(
        ::std::mem::size_of::<nite_BoundingBox>(),
        24usize,
        concat!("Size of: ", stringify!(nite_BoundingBox))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_BoundingBox>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_BoundingBox))
    );
}
#[doc = "Provides a simple array class used throughout the API. Wraps a primitive array"]
#[doc = "of objects, holding the elements and their count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_Array<T> {
    pub m_size: ::std::os::raw::c_int,
    pub m_data: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = "UserId is a persistent ID for a specific user detected by the UserTracker algorithm."]
#[doc = "While the user is known, it will have the same ID."]
pub type nite_UserId = ::std::os::raw::c_short;
#[doc = "This class wraps the output from the NiTE Pose Detection algorithms."]
#[doc = ""]
#[doc = "NiTE provides the ability for applications to detect whether a user is in a specific pose."]
#[doc = "This is most commonly used for skeleton calibration.  The algorithm passes through a number"]
#[doc = "of different states during the process of Pose Detection."]
#[doc = ""]
#[doc = "For each user being analyzed, this class stores the pose being detected and the state of"]
#[doc = "that detection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_PoseData {
    pub _base: NitePoseData,
}
#[test]
fn bindgen_test_layout_nite_PoseData() {
    assert_eq!(
        ::std::mem::size_of::<nite_PoseData>(),
        8usize,
        concat!("Size of: ", stringify!(nite_PoseData))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_PoseData>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_PoseData))
    );
}
#[doc = "This class stores the output from the @ref nite::UserTracker algorithm."]
#[doc = ""]
#[doc = "The basic purpose of the User Tracker algorithm is to analyze a depth frame and to locate all users in"]
#[doc = "the scene, to indicate which pixels belong to which user, and which pixels belong to the background."]
#[doc = ""]
#[doc = ""]
#[doc = "The output is in the form of a two dimensional array with the same dimensions"]
#[doc = "as the depth frame that was used as the input to UserTracker.  Each element of the"]
#[doc = "array corresponds to a single pixel from the depth map, and indicates the UserID"]
#[doc = "of the user which occupies that pixel."]
#[doc = ""]
#[doc = "The UserId value 0 is used to indicate pixels that contain no users (ie background)."]
#[doc = ""]
#[doc = "@see UserTracker for more information about this algorithm."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_UserMap {
    pub _base: NiteUserMap,
}
#[test]
fn bindgen_test_layout_nite_UserMap() {
    assert_eq!(
        ::std::mem::size_of::<nite_UserMap>(),
        24usize,
        concat!("Size of: ", stringify!(nite_UserMap))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_UserMap>(),
        8usize,
        concat!("Alignment of ", stringify!(nite_UserMap))
    );
}
#[doc = "This class provides a data structure to store the output of the Skeleton algorithm."]
#[doc = ""]
#[doc = "The basic purpose of the skeleton algorithm is to locate each of a user's joints, and"]
#[doc = "to estimate the position and orientation of each joint in space.  The output from the Skeleton algorithm is"]
#[doc = "stored as a series of SkeletonJoint objects."]
#[doc = ""]
#[doc = "@see nite::Skeleton for more information about the Skeleton algorithm."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_SkeletonJoint {
    pub _base: NiteSkeletonJoint,
}
#[test]
fn bindgen_test_layout_nite_SkeletonJoint() {
    assert_eq!(
        ::std::mem::size_of::<nite_SkeletonJoint>(),
        40usize,
        concat!("Size of: ", stringify!(nite_SkeletonJoint))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_SkeletonJoint>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_SkeletonJoint))
    );
}
#[doc = "This is the main class for the skeleton algorithm."]
#[doc = ""]
#[doc = "The purpose of the skeleton algorithm is to analyze a user outline supplied by the User Tracker"]
#[doc = "algorithm, and to locate the position of that user's joints in space (eg knees, elbows, head, etc)."]
#[doc = "The orientation of the user's joints is also calculated.  Where joints are not visible, the algorithm"]
#[doc = "will make a best guess about the joint.  For all data calculated, confidence values are also"]
#[doc = "created to help an application understand if the algorithm is sure about the data, or if it is \"guessing\"."]
#[doc = ""]
#[doc = "Nite offers two types of skeletons algorithms.  One requires the user to assume a specific \"calibration pose\""]
#[doc = "before calibration can be attempted.  The other does not require a specific pose from the user, but will require"]
#[doc = "a few seconds to settle down as it learns a user's body shape.  The algorithm used sometimes depends on"]
#[doc = "the platform being used -- for example, the ARM version of Nite currently only offers the version that"]
#[doc = "requires a calibration pose."]
#[doc = ""]
#[doc = "All skeleton joint positions are given in \"real world\" data coordinates, using the same conventions as"]
#[doc = "OpenNI 2.0.  See the online documentation for OpenNI 2.0 for more information on the coordinate systems"]
#[doc = "used with the skeleton."]
#[doc = ""]
#[doc = "@see SkeletonJoint for the output data format of the skeleton."]
#[doc = "@see JointType enumeration for a list of all joints detected by the skeleton."]
#[doc = "@see UserTracker to understand where the input data to the skeleton comes from."]
#[doc = "@see SkeletonState enumeration for a list of possible skeleton states."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_Skeleton {
    pub _base: NiteSkeleton,
}
#[test]
fn bindgen_test_layout_nite_Skeleton() {
    assert_eq!(
        ::std::mem::size_of::<nite_Skeleton>(),
        604usize,
        concat!("Size of: ", stringify!(nite_Skeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Skeleton>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_Skeleton))
    );
}
#[doc = "Provides the current information available about a specific user detected by the UserTracker."]
#[doc = ""]
#[doc = "Note that some data is provided in depth (\"projective\") coordinates, and other data is provided"]
#[doc = "in world (\"real world\") coordinates.  See the OpenNI 2.0 documentation for information on the two"]
#[doc = "coordinate systems used and how to convert between them."]
#[doc = ""]
#[doc = "@see UserTracker for more information on how this data is generated."]
#[doc = "@see Skeleton for more information on a user's skeleton"]
#[doc = "@see UserMap for information on locating a specific user in the scene."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_UserData {
    pub _base: NiteUserData,
}
#[test]
fn bindgen_test_layout_nite_UserData() {
    assert_eq!(
        ::std::mem::size_of::<nite_UserData>(),
        664usize,
        concat!("Size of: ", stringify!(nite_UserData))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_UserData>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_UserData))
    );
}
#[doc = "This class stores a snapshot of a single frame of output from the UserTracker algorithm.  This frame will"]
#[doc = "correspond to a single input depth frame.  It holds all info on users, as well as information on the floor plane."]
#[doc = ""]
#[doc = "@see @ref UserData For detailed info on specific users"]
#[doc = "@see @ref Skeleton For user skeleton data"]
#[doc = "@see @ref UserMap For user positions in the frame"]
#[doc = "@see @ref UserTracker For information on starting the user tracker algorithms to detect all of this data."]
#[doc = "@see @ref HandTrackerFrameRef for the equivalent information when hand tracking."]
#[repr(C)]
#[derive(Debug)]
pub struct nite_UserTrackerFrameRef {
    pub m_users: nite_Array<nite_UserData>,
    pub m_pFrame: *mut NiteUserTrackerFrame,
    pub m_userTrackerHandle: NiteUserTrackerHandle,
    pub m_depthFrame: openni_VideoFrameRef,
}

impl nite_UserTrackerFrameRef {
    pub fn setReference(&mut self, userTrackerHandle: NiteUserTrackerHandle, pFrame: &mut NiteUserTrackerFrame){
        self.release();
        self.m_userTrackerHandle = userTrackerHandle;
        self.m_pFrame = pFrame as *mut NiteUserTrackerFrame;
        self.m_depthFrame._setFrame(pFrame.pDepthFrame);
    }

    pub fn getUsers(&self) -> nite_Array<nite_UserData> {
        return self.m_users
    }

    fn release(&mut self){
        if (std::ptr::null() != self.m_pFrame){
            unsafe {niteUserTrackerFrameRelease(self.m_userTrackerHandle, self.m_pFrame)};
        }
    }

}

#[test]
fn bindgen_test_layout_nite_UserTrackerFrameRef() {
    assert_eq!(
        ::std::mem::size_of::<nite_UserTrackerFrameRef>(),
        40usize,
        concat!("Size of: ", stringify!(nite_UserTrackerFrameRef))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_UserTrackerFrameRef>(),
        8usize,
        concat!("Alignment of ", stringify!(nite_UserTrackerFrameRef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTrackerFrameRef>())).m_users as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTrackerFrameRef),
            "::",
            stringify!(m_users)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTrackerFrameRef>())).m_pFrame as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTrackerFrameRef),
            "::",
            stringify!(m_pFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTrackerFrameRef>())).m_userTrackerHandle as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTrackerFrameRef),
            "::",
            stringify!(m_userTrackerHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTrackerFrameRef>())).m_depthFrame as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTrackerFrameRef),
            "::",
            stringify!(m_depthFrame)
        )
    );
}
#[doc = "This is the main object of the User Tracker algorithm.  It provides access to one half of the"]
#[doc = "algorithms provided by NiTE.  Scene segmentation, skeleton, floor plane detection, and pose"]
#[doc = "detection are all provided by this class."]
#[doc = ""]
#[doc = "The first purpose of the User Tracker algorithm is to find all of the active users in a specific scene."]
#[doc = "It individually tracks each human it finds, and provides the means to seperate their outline from"]
#[doc = "each other and from the background.  Once the scene has been segmented, the User Tracker is also used to initiate Skeleton"]
#[doc = "Tracking and Pose Detection algorithms."]
#[doc = ""]
#[doc = "Each user is provided an ID as they are detected.  The user ID remains constant as long as the"]
#[doc = "user remains in the frame.  If a user leaves the field of view of the camera, or tracking of that"]
#[doc = "user is otherwise lost, the user may have a different ID when he is detected again.  There is"]
#[doc = "currently no mechanism that provides persistant recognition of individuals when they are not being"]
#[doc = "actively tracking.  If this functionality is desired, it will need to be implimented at the"]
#[doc = "application level."]
#[doc = ""]
#[doc = "A listener class is provided to allow event based interaction with this algorithm."]
#[doc = ""]
#[doc = "@see UserMap for the output format of the User Tracker algorithm"]
#[doc = "@see UserData for additional data output by this format"]
#[doc = "@see Skeleton if you are also interested in tracking a user's skeleton"]
#[doc = "@see NiTE for a couple of static functions that must be run before User Tracker can be used"]
#[doc = "@see @ref HandTracker for Gesture and Hand tracking algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct nite_UserTracker {
    pub m_userTrackerHandle: *mut MaybeUninit<NiteUserTracker>,
}

impl nite_UserTracker {
    pub fn create(&mut self, pDevice: Option<OpenNI::Device>) -> NiteStatus {
        if (self.isValid()){
            return nite_Status_STATUS_OUT_OF_FLOW;
        }

        if let None = pDevice {
            return unsafe {niteInitializeUserTracker(&mut (*(self.m_userTrackerHandle)).as_mut_ptr())};
        }

        return unsafe {niteInitializeUserTrackerByDevice(&mut pDevice.unwrap() as *mut OpenNI::Device as *mut libc::c_void, &mut (*(self.m_userTrackerHandle)).as_mut_ptr())}
    }

    pub fn destroy(&mut self){
        if (self.isValid()){
            unsafe {niteShutdownUserTracker((*(self.m_userTrackerHandle)).as_mut_ptr())};
        }
    }

    pub fn readFrame(&mut self, pFrame:*mut nite_UserTrackerFrameRef) -> NiteStatus {
        let mut pNiteFrame:MaybeUninit<NiteUserTrackerFrame> = MaybeUninit::<NiteUserTrackerFrame>::uninit();
        let rc:NiteStatus = unsafe {niteReadUserTrackerFrame((*(self.m_userTrackerHandle)).as_mut_ptr(), pNiteFrame.as_mut_ptr() as *mut *mut NiteUserTrackerFrame)};
        unsafe {nite_UserTrackerFrameRef::setReference(&mut (*pFrame), (*(self.m_userTrackerHandle)).as_mut_ptr(), &mut (*pNiteFrame.as_mut_ptr()))}
        return rc;
    }

    pub fn startSkeletonTracking(&self, id: nite_UserId) -> NiteStatus {
        return unsafe {niteStartSkeletonTracking((*(self.m_userTrackerHandle)).as_mut_ptr(), id)};
    }

    fn isValid(&self) -> bool {
        return !self.m_userTrackerHandle.is_null();
    }
}

#[repr(C)]
pub struct nite_UserTracker_NewFrameListener__bindgen_vtable(::std::os::raw::c_void);
#[doc = "This is a listener class that is used to react to events generated by the @ref UserTracker class."]
#[doc = ""]
#[doc = "To use this class, you must derive a class from it that implements the @ref onNewFrame() function.  This"]
#[doc = "is the function that will be called when an event is generated."]
#[doc = ""]
#[doc = "Create a new instance of your derived class.  Then, use the @ref UserTracker::addNewFrameListener()"]
#[doc = "function to add the listener to the @ref UserTracker.  When that @ref UserTracker generates an onNewFrame event, \\"]
#[doc = "the specified callback function will be called."]
#[doc = ""]
#[doc = "The onNewFrame event is currently the only event type that this listener is designed to work with."]
#[doc = ""]
#[doc = "@see @ref UserTracker for the source of this listener's events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_UserTracker_NewFrameListener {
    pub vtable_: *const nite_UserTracker_NewFrameListener__bindgen_vtable,
    pub m_userTrackerCallbacks: NiteUserTrackerCallbacks,
    pub m_pUserTracker: *mut nite_UserTracker,
}
#[test]
fn bindgen_test_layout_nite_UserTracker_NewFrameListener() {
    assert_eq!(
        ::std::mem::size_of::<nite_UserTracker_NewFrameListener>(),
        24usize,
        concat!("Size of: ", stringify!(nite_UserTracker_NewFrameListener))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_UserTracker_NewFrameListener>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nite_UserTracker_NewFrameListener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTracker_NewFrameListener>())).m_userTrackerCallbacks
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTracker_NewFrameListener),
            "::",
            stringify!(m_userTrackerCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTracker_NewFrameListener>())).m_pUserTracker as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTracker_NewFrameListener),
            "::",
            stringify!(m_pUserTracker)
        )
    );
}
#[test]
fn bindgen_test_layout_nite_UserTracker() {
    assert_eq!(
        ::std::mem::size_of::<nite_UserTracker>(),
        8usize,
        concat!("Size of: ", stringify!(nite_UserTracker))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_UserTracker>(),
        8usize,
        concat!("Alignment of ", stringify!(nite_UserTracker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTracker>())).m_userTrackerHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTracker),
            "::",
            stringify!(m_userTrackerHandle)
        )
    );
}
pub type nite_HandId = ::std::os::raw::c_short;
#[doc = "This class stores data on a gesture that is being detected.  \"Gestures\" in this context indicate"]
#[doc = "gestures detected directly from the depthmap, so there are no handpoint ID's at this stage.  Objects"]
#[doc = "of this class store the data for a specific instance of a specific gesture."]
#[doc = ""]
#[doc = "The type, position in space, and completion status of the gesture can all be tracked."]
#[doc = ""]
#[doc = "All positions are given in \"real world\" coordinates.  See the OpenNI 2.0 documentation for more information"]
#[doc = "on the coordinate systems used by OpenNI/NiTE."]
#[doc = ""]
#[doc = "@see @ref GestureType enumeration for a list of available hand gestures."]
#[doc = "@see @ref HandTracker for more information on using gestures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_GestureData {
    pub _base: NiteGestureData,
}
#[test]
fn bindgen_test_layout_nite_GestureData() {
    assert_eq!(
        ::std::mem::size_of::<nite_GestureData>(),
        20usize,
        concat!("Size of: ", stringify!(nite_GestureData))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_GestureData>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_GestureData))
    );
}
#[doc = "This class stores data on a single hand during a single frame of hand detection by the @HandTracker."]
#[doc = ""]
#[doc = "It can be used to find out where the hand is in space, the hand's ID, and the tracking status."]
#[doc = ""]
#[doc = "All positions are given in \"real world\" coordinates.  See the OpenNI 2.0 documentation for more information"]
#[doc = "on the coordinate systems used by OpenNI/NiTE."]
#[doc = ""]
#[doc = "@see HandTracker for more information on hand tracking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_HandData {
    pub _base: NiteHandData,
}
#[test]
fn bindgen_test_layout_nite_HandData() {
    assert_eq!(
        ::std::mem::size_of::<nite_HandData>(),
        20usize,
        concat!("Size of: ", stringify!(nite_HandData))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_HandData>(),
        4usize,
        concat!("Alignment of ", stringify!(nite_HandData))
    );
}
#[doc = "Snapshot of the Hand Tracker algorithm.  It contains all output from a single frame of"]
#[doc = "the Hand Tracking algorithm, which corresponds to a single input depth frame."]
#[doc = ""]
#[doc = "It holds all the hands identified at this time, as well as the detected gestures."]
#[doc = ""]
#[doc = "@see HandTracker for how this data is created"]
#[repr(C)]
#[derive(Debug)]
pub struct nite_HandTrackerFrameRef {
    pub m_pFrame: *mut NiteHandTrackerFrame,
    pub m_handTracker: NiteHandTrackerHandle,
    pub m_depthFrame: openni_VideoFrameRef,
    pub m_hands: nite_Array<nite_HandData>,
    pub m_gestures: nite_Array<nite_GestureData>,
}
#[test]
fn bindgen_test_layout_nite_HandTrackerFrameRef() {
    assert_eq!(
        ::std::mem::size_of::<nite_HandTrackerFrameRef>(),
        56usize,
        concat!("Size of: ", stringify!(nite_HandTrackerFrameRef))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_HandTrackerFrameRef>(),
        8usize,
        concat!("Alignment of ", stringify!(nite_HandTrackerFrameRef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTrackerFrameRef>())).m_pFrame as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTrackerFrameRef),
            "::",
            stringify!(m_pFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTrackerFrameRef>())).m_handTracker as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTrackerFrameRef),
            "::",
            stringify!(m_handTracker)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTrackerFrameRef>())).m_depthFrame as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTrackerFrameRef),
            "::",
            stringify!(m_depthFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTrackerFrameRef>())).m_hands as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTrackerFrameRef),
            "::",
            stringify!(m_hands)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTrackerFrameRef>())).m_gestures as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTrackerFrameRef),
            "::",
            stringify!(m_gestures)
        )
    );
}
#[doc = "This is the main object of the Hand Tracker algorithm.  It (along with @ref UserTracker) is"]
#[doc = "one of two main classes in NiTE.  All NiTE algorithms are accessable through one of these two classes."]
#[doc = ""]
#[doc = "@ref HandTracker provides access to all algorithms relates to tracking individual hands, as well as"]
#[doc = "detecting gestures in the depthmap."]
#[doc = ""]
#[doc = "The core of the hand tracking is an algorithm that finds human hands in each from of the depthmap, and"]
#[doc = "reports the position of those hands in space.  This can be used for simple detection of higher level"]
#[doc = "gestures and implimentation of gesture based user interfaces.  Unlike full body tracking algorithms,"]
#[doc = "handpoint based tracking works on users that are sitting and does not require a full body be visible."]
#[doc = ""]
#[doc = "Gesture tracking is generally used to initiate hand tracking.  It allows detection of gestures in the"]
#[doc = "raw depth map, without requiring hand points (in contrast to higher-level gestures that might be"]
#[doc = "used to impliment a UI using handpoints).  These gestures can be located in space to provide a hint"]
#[doc = "to the hand tracking algorithm on where to start tracking."]
#[doc = ""]
#[doc = "The output of the HandTracker occurs one frame at a time.  For each input depth frame, a hand tracking frame"]
#[doc = "is output with hand positions, gesture positions, etc.  A listener class is provided that allows for event"]
#[doc = "driven reaction to each new frame as it arrives."]
#[doc = ""]
#[doc = "Note that creating a HandTracker requires a valid OpenNI 2.0 Device to be initialized in order to provide"]
#[doc = "depth information.  See the OpenNI 2.0 documenation for information on connecting a device and starting"]
#[doc = "the stream of depth maps that will drive this algorithm."]
#[doc = ""]
#[doc = "@see @ref UserTracker If you want to track full body motion, skeletons, find a floor plane, or detect poses."]
#[doc = "@see @ref NiTE For a list of static functions that must be used before using HandTracker"]
#[repr(C)]
#[derive(Debug)]
pub struct nite_HandTracker {
    pub m_handTrackerHandle: NiteHandTrackerHandle,
}
#[repr(C)]
pub struct nite_HandTracker_NewFrameListener__bindgen_vtable(::std::os::raw::c_void);
#[doc = "This is a listener class that is used to react to events generated by the @ref HandTracker class."]
#[doc = ""]
#[doc = "To use this class, you must derive a class from it that implements the @ref onNewFrame() function.  This"]
#[doc = "is the function that will be called when an event is generated."]
#[doc = ""]
#[doc = "Create a new instance of your derived class.  Then, use the @ref HandTracker::addNewFrameListener()"]
#[doc = "function to add the listener to the @ref HandTracker.  When that @ref HandTracker generates an onNewFrame event, \\"]
#[doc = "the specified callback function will be called."]
#[doc = ""]
#[doc = "The onNewFrame event is currently the only event type that this listener is designed to work with."]
#[doc = ""]
#[doc = "@see @ref HandTracker for the source of this listener's events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_HandTracker_NewFrameListener {
    pub vtable_: *const nite_HandTracker_NewFrameListener__bindgen_vtable,
    pub m_handTrackerCallbacks: NiteHandTrackerCallbacks,
    pub m_pHandTracker: *mut nite_HandTracker,
}
#[test]
fn bindgen_test_layout_nite_HandTracker_NewFrameListener() {
    assert_eq!(
        ::std::mem::size_of::<nite_HandTracker_NewFrameListener>(),
        24usize,
        concat!("Size of: ", stringify!(nite_HandTracker_NewFrameListener))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_HandTracker_NewFrameListener>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nite_HandTracker_NewFrameListener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTracker_NewFrameListener>())).m_handTrackerCallbacks
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTracker_NewFrameListener),
            "::",
            stringify!(m_handTrackerCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTracker_NewFrameListener>())).m_pHandTracker as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTracker_NewFrameListener),
            "::",
            stringify!(m_pHandTracker)
        )
    );
}
#[test]
fn bindgen_test_layout_nite_HandTracker() {
    assert_eq!(
        ::std::mem::size_of::<nite_HandTracker>(),
        8usize,
        concat!("Size of: ", stringify!(nite_HandTracker))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_HandTracker>(),
        8usize,
        concat!("Alignment of ", stringify!(nite_HandTracker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTracker>())).m_handTrackerHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTracker),
            "::",
            stringify!(m_handTrackerHandle)
        )
    );
}
#[doc = "The NiTE class is a static entry point to the library."]
#[doc = ""]
#[doc = "All applications that expect to use the NiTE middleware should run the NiTE.initialize() function before"]
#[doc = "using any other API calls.  Before the application exits, the application should run the NiTE.shutdown() function to"]
#[doc = "properly close the API."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_NiTE {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_nite_NiTE() {
    assert_eq!(
        ::std::mem::size_of::<nite_NiTE>(),
        1usize,
        concat!("Size of: ", stringify!(nite_NiTE))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_NiTE>(),
        1usize,
        concat!("Alignment of ", stringify!(nite_NiTE))
    );
}
#[test]
fn __bindgen_test_layout_openni_Array_open0_openni_VideoMode_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<openni_Array<openni_VideoMode>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(openni_Array<openni_VideoMode>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<openni_Array<openni_VideoMode>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(openni_Array<openni_VideoMode>)
        )
    );
}
#[test]
fn __bindgen_test_layout_nite_Array_open0_nite_UserData_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<nite_Array<nite_UserData>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(nite_Array<nite_UserData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Array<nite_UserData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(nite_Array<nite_UserData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_nite_Array_open0_nite_UserData_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<nite_Array<nite_UserData>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(nite_Array<nite_UserData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Array<nite_UserData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(nite_Array<nite_UserData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_nite_Array_open0_nite_HandData_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<nite_Array<nite_HandData>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(nite_Array<nite_HandData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Array<nite_HandData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(nite_Array<nite_HandData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_nite_Array_open0_nite_GestureData_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<nite_Array<nite_GestureData>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(nite_Array<nite_GestureData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Array<nite_GestureData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(nite_Array<nite_GestureData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_nite_Array_open0_nite_HandData_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<nite_Array<nite_HandData>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(nite_Array<nite_HandData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Array<nite_HandData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(nite_Array<nite_HandData>)
        )
    );
}
#[test]
fn __bindgen_test_layout_nite_Array_open0_nite_GestureData_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<nite_Array<nite_GestureData>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(nite_Array<nite_GestureData>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nite_Array<nite_GestureData>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(nite_Array<nite_GestureData>)
        )
    );
}
