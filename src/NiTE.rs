/* automatically generated by rust-bindgen 0.58.1 */

mod OpenNI;

use OpenNI::OniFrame;
use OpenNI::OniGeneralCallback;

pub const NITE_JOINT_COUNT: u32 = 15;
pub const NITE_POSE_COUNT: u32 = 2;
pub const NITE_VERSION_MAJOR: u32 = 2;
pub const NITE_VERSION_MINOR: u32 = 2;
pub const NITE_VERSION_MAINTENANCE: u32 = 0;
pub const NITE_VERSION_BUILD: u32 = 5;
pub const NITE_VERSION: u32 = 202000005;
pub const NiteJointType_NITE_JOINT_HEAD: NiteJointType = 0;
pub const NiteJointType_NITE_JOINT_NECK: NiteJointType = 1;
pub const NiteJointType_NITE_JOINT_LEFT_SHOULDER: NiteJointType = 2;
pub const NiteJointType_NITE_JOINT_RIGHT_SHOULDER: NiteJointType = 3;
pub const NiteJointType_NITE_JOINT_LEFT_ELBOW: NiteJointType = 4;
pub const NiteJointType_NITE_JOINT_RIGHT_ELBOW: NiteJointType = 5;
pub const NiteJointType_NITE_JOINT_LEFT_HAND: NiteJointType = 6;
pub const NiteJointType_NITE_JOINT_RIGHT_HAND: NiteJointType = 7;
pub const NiteJointType_NITE_JOINT_TORSO: NiteJointType = 8;
pub const NiteJointType_NITE_JOINT_LEFT_HIP: NiteJointType = 9;
pub const NiteJointType_NITE_JOINT_RIGHT_HIP: NiteJointType = 10;
pub const NiteJointType_NITE_JOINT_LEFT_KNEE: NiteJointType = 11;
pub const NiteJointType_NITE_JOINT_RIGHT_KNEE: NiteJointType = 12;
pub const NiteJointType_NITE_JOINT_LEFT_FOOT: NiteJointType = 13;
pub const NiteJointType_NITE_JOINT_RIGHT_FOOT: NiteJointType = 14;
#[doc = " Available joints in skeleton"]
pub type NiteJointType = ::std::os::raw::c_uint;
#[doc = " No skeleton - skeleton was not requested"]
pub const NiteSkeletonState_NITE_SKELETON_NONE: NiteSkeletonState = 0;
#[doc = " Skeleton requested, but still unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATING: NiteSkeletonState = 1;
#[doc = " Skeleton available"]
pub const NiteSkeletonState_NITE_SKELETON_TRACKED: NiteSkeletonState = 2;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_NOT_IN_POSE: NiteSkeletonState = 3;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_HANDS: NiteSkeletonState = 4;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_HEAD: NiteSkeletonState = 5;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_LEGS: NiteSkeletonState = 6;
#[doc = " Possible reasons as to why skeleton is unavailable"]
pub const NiteSkeletonState_NITE_SKELETON_CALIBRATION_ERROR_TORSO: NiteSkeletonState = 7;
#[doc = " Possible states of the skeleton"]
pub type NiteSkeletonState = ::std::os::raw::c_uint;
#[doc = " User is visible and already known"]
pub const NiteUserState_NITE_USER_STATE_VISIBLE: NiteUserState = 1;
#[doc = " User is new - this is the first time the user is available"]
pub const NiteUserState_NITE_USER_STATE_NEW: NiteUserState = 2;
#[doc = " User is lost. This is the last time this user will be seen"]
pub const NiteUserState_NITE_USER_STATE_LOST: NiteUserState = 4;
#[doc = " Possible states of the user"]
pub type NiteUserState = ::std::os::raw::c_uint;
pub const NiteStatus_NITE_STATUS_OK: NiteStatus = 0;
pub const NiteStatus_NITE_STATUS_ERROR: NiteStatus = 1;
pub const NiteStatus_NITE_STATUS_BAD_USER_ID: NiteStatus = 2;
pub const NiteStatus_NITE_STATUS_OUT_OF_FLOW: NiteStatus = 3;
#[doc = " Possible failure values"]
pub type NiteStatus = ::std::os::raw::c_uint;
pub const NitePoseType_NITE_POSE_PSI: NitePoseType = 0;
pub const NitePoseType_NITE_POSE_CROSSED_HANDS: NitePoseType = 1;
pub type NitePoseType = ::std::os::raw::c_uint;
pub const NitePoseState_NITE_POSE_STATE_DETECTING: NitePoseState = 1;
pub const NitePoseState_NITE_POSE_STATE_IN_POSE: NitePoseState = 2;
pub const NitePoseState_NITE_POSE_STATE_ENTER: NitePoseState = 4;
pub const NitePoseState_NITE_POSE_STATE_EXIT: NitePoseState = 8;
pub type NitePoseState = ::std::os::raw::c_uint;
pub const NiteGestureType_NITE_GESTURE_WAVE: NiteGestureType = 0;
pub const NiteGestureType_NITE_GESTURE_CLICK: NiteGestureType = 1;
pub const NiteGestureType_NITE_GESTURE_HAND_RAISE: NiteGestureType = 2;
#[doc = " Available gestures types"]
pub type NiteGestureType = ::std::os::raw::c_uint;
pub const NiteGestureState_NITE_GESTURE_STATE_NEW: NiteGestureState = 1;
pub const NiteGestureState_NITE_GESTURE_STATE_IN_PROGRESS: NiteGestureState = 2;
pub const NiteGestureState_NITE_GESTURE_STATE_COMPLETED: NiteGestureState = 4;
#[doc = " Possible state of a gesture. Currently only 'Complete' is used."]
pub type NiteGestureState = ::std::os::raw::c_uint;
#[doc = " This hand was lost. It is the last frame in which it will be provided"]
pub const NiteHandState_NITE_HAND_STATE_LOST: NiteHandState = 0;
#[doc = " This is a new hand - it is the first frame in which it is available"]
pub const NiteHandState_NITE_HAND_STATE_NEW: NiteHandState = 1;
#[doc = " This is a known hand"]
pub const NiteHandState_NITE_HAND_STATE_TRACKED: NiteHandState = 2;
#[doc = " This is a known hand, and in this frame it's very near the edge of the field of view"]
pub const NiteHandState_NITE_HAND_STATE_TOUCHING_FOV: NiteHandState = 4;
#[doc = " Possible state of a hand"]
pub type NiteHandState = ::std::os::raw::c_uint;
pub type NiteUserId = ::std::os::raw::c_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserTracker {
    _unused: [u8; 0],
}
pub type NiteUserTrackerHandle = *mut NiteUserTracker;
#[doc = " 3D Point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NitePoint3f {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_NitePoint3f() {
    assert_eq!(
        ::std::mem::size_of::<NitePoint3f>(),
        12usize,
        concat!("Size of: ", stringify!(NitePoint3f))
    );
    assert_eq!(
        ::std::mem::align_of::<NitePoint3f>(),
        4usize,
        concat!("Alignment of ", stringify!(NitePoint3f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoint3f>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoint3f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoint3f>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoint3f),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoint3f>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoint3f),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " Quaternion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteQuaternion {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_NiteQuaternion() {
    assert_eq!(
        ::std::mem::size_of::<NiteQuaternion>(),
        16usize,
        concat!("Size of: ", stringify!(NiteQuaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteQuaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteQuaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteQuaternion>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteQuaternion),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " Single joint of a skeleton"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteSkeletonJoint {
    #[doc = " Type of the joint"]
    pub jointType: NiteJointType,
    #[doc = " Position of the joint - in real world coordinates"]
    pub position: NitePoint3f,
    pub positionConfidence: f32,
    #[doc = " Orientation of the joint"]
    pub orientation: NiteQuaternion,
    pub orientationConfidence: f32,
}
#[test]
fn bindgen_test_layout_NiteSkeletonJoint() {
    assert_eq!(
        ::std::mem::size_of::<NiteSkeletonJoint>(),
        40usize,
        concat!("Size of: ", stringify!(NiteSkeletonJoint))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteSkeletonJoint>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteSkeletonJoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeletonJoint>())).jointType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(jointType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeletonJoint>())).position as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteSkeletonJoint>())).positionConfidence as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(positionConfidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeletonJoint>())).orientation as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteSkeletonJoint>())).orientationConfidence as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeletonJoint),
            "::",
            stringify!(orientationConfidence)
        )
    );
}
#[doc = " 3D Box"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteBoundingBox {
    pub min: NitePoint3f,
    pub max: NitePoint3f,
}
#[test]
fn bindgen_test_layout_NiteBoundingBox() {
    assert_eq!(
        ::std::mem::size_of::<NiteBoundingBox>(),
        24usize,
        concat!("Size of: ", stringify!(NiteBoundingBox))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteBoundingBox>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteBoundingBox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteBoundingBox>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteBoundingBox),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteBoundingBox>())).max as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteBoundingBox),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NitePoseData {
    pub type_: NitePoseType,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NitePoseData() {
    assert_eq!(
        ::std::mem::size_of::<NitePoseData>(),
        8usize,
        concat!("Size of: ", stringify!(NitePoseData))
    );
    assert_eq!(
        ::std::mem::align_of::<NitePoseData>(),
        4usize,
        concat!("Alignment of ", stringify!(NitePoseData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoseData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoseData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePoseData>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePoseData),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Skeleton - a set of joints"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteSkeleton {
    pub joints: [NiteSkeletonJoint; 15usize],
    pub state: NiteSkeletonState,
}
#[test]
fn bindgen_test_layout_NiteSkeleton() {
    assert_eq!(
        ::std::mem::size_of::<NiteSkeleton>(),
        604usize,
        concat!("Size of: ", stringify!(NiteSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteSkeleton>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteSkeleton))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeleton>())).joints as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeleton),
            "::",
            stringify!(joints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteSkeleton>())).state as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteSkeleton),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Snapshot of a specific user"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserData {
    pub id: NiteUserId,
    pub boundingBox: NiteBoundingBox,
    pub centerOfMass: NitePoint3f,
    pub state: ::std::os::raw::c_int,
    pub skeleton: NiteSkeleton,
    pub poses: [NitePoseData; 2usize],
}
#[test]
fn bindgen_test_layout_NiteUserData() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserData>(),
        664usize,
        concat!("Size of: ", stringify!(NiteUserData))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserData>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteUserData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).boundingBox as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(boundingBox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).centerOfMass as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(centerOfMass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).skeleton as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(skeleton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserData>())).poses as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserData),
            "::",
            stringify!(poses)
        )
    );
}
#[doc = " Snapshot of the scene segmentation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserMap {
    pub pixels: *mut NiteUserId,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub stride: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteUserMap() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserMap>(),
        24usize,
        concat!("Size of: ", stringify!(NiteUserMap))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserMap>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteUserMap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).pixels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserMap>())).stride as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserMap),
            "::",
            stringify!(stride)
        )
    );
}
#[doc = " 3D Plane"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NitePlane {
    pub point: NitePoint3f,
    pub normal: NitePoint3f,
}
#[test]
fn bindgen_test_layout_NitePlane() {
    assert_eq!(
        ::std::mem::size_of::<NitePlane>(),
        24usize,
        concat!("Size of: ", stringify!(NitePlane))
    );
    assert_eq!(
        ::std::mem::align_of::<NitePlane>(),
        4usize,
        concat!("Alignment of ", stringify!(NitePlane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePlane>())).point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePlane),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NitePlane>())).normal as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NitePlane),
            "::",
            stringify!(normal)
        )
    );
}
#[doc = " Output snapshot of the User Tracker algorithm"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserTrackerFrame {
    #[doc = " Number of users"]
    pub userCount: ::std::os::raw::c_int,
    #[doc = " List of users"]
    pub pUser: *mut [NiteUserData],
    #[doc = " Scene segmentation map"]
    pub userMap: NiteUserMap,
    #[doc = " The depth frame from which this data was learned"]
    pub pDepthFrame: *mut OniFrame,
    pub timestamp: ::std::os::raw::c_ulonglong,
    pub frameIndex: ::std::os::raw::c_int,
    #[doc = " Confidence of the floor plane"]
    pub floorConfidence: f32,
    #[doc = " Floor plane"]
    pub floor: NitePlane,
}
#[test]
fn bindgen_test_layout_NiteUserTrackerFrame() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserTrackerFrame>(),
        88usize,
        concat!("Size of: ", stringify!(NiteUserTrackerFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserTrackerFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteUserTrackerFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).userCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(userCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).pUser as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(pUser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).userMap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(userMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteUserTrackerFrame>())).pDepthFrame as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(pDepthFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).timestamp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).frameIndex as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(frameIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteUserTrackerFrame>())).floorConfidence as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(floorConfidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteUserTrackerFrame>())).floor as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerFrame),
            "::",
            stringify!(floor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteUserTrackerCallbacks {
    pub readyForNextFrame: OniGeneralCallback,
}
#[test]
fn bindgen_test_layout_NiteUserTrackerCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<NiteUserTrackerCallbacks>(),
        8usize,
        concat!("Size of: ", stringify!(NiteUserTrackerCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteUserTrackerCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteUserTrackerCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteUserTrackerCallbacks>())).readyForNextFrame as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteUserTrackerCallbacks),
            "::",
            stringify!(readyForNextFrame)
        )
    );
}
pub type NiteHandId = ::std::os::raw::c_short;
#[doc = " A snapshot of a specific hand"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandData {
    pub id: NiteHandId,
    pub position: NitePoint3f,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteHandData() {
    assert_eq!(
        ::std::mem::size_of::<NiteHandData>(),
        20usize,
        concat!("Size of: ", stringify!(NiteHandData))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteHandData>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteHandData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandData>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandData>())).position as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandData),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandData>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandData),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " A snapshot of a specific gesture"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteGestureData {
    pub type_: NiteGestureType,
    pub currentPosition: NitePoint3f,
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteGestureData() {
    assert_eq!(
        ::std::mem::size_of::<NiteGestureData>(),
        20usize,
        concat!("Size of: ", stringify!(NiteGestureData))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteGestureData>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteGestureData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteGestureData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteGestureData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteGestureData>())).currentPosition as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteGestureData),
            "::",
            stringify!(currentPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteGestureData>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteGestureData),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Output snapshot of the Hand Tracker algorithm"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandTrackerFrame {
    #[doc = " Number of hands"]
    pub handCount: ::std::os::raw::c_int,
    #[doc = " List of hands"]
    pub pHands: *mut NiteHandData,
    #[doc = " Number of gestures"]
    pub gestureCount: ::std::os::raw::c_int,
    #[doc = " List of gestures"]
    pub pGestures: *mut NiteGestureData,
    #[doc = " The depth frame from which this data was learned"]
    pub pDepthFrame: *mut OniFrame,
    pub timestamp: ::std::os::raw::c_ulonglong,
    pub frameIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteHandTrackerFrame() {
    assert_eq!(
        ::std::mem::size_of::<NiteHandTrackerFrame>(),
        56usize,
        concat!("Size of: ", stringify!(NiteHandTrackerFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteHandTrackerFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteHandTrackerFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).handCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(handCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).pHands as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(pHands)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteHandTrackerFrame>())).gestureCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(gestureCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).pGestures as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(pGestures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteHandTrackerFrame>())).pDepthFrame as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(pDepthFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).timestamp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteHandTrackerFrame>())).frameIndex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerFrame),
            "::",
            stringify!(frameIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandTrackerCallbacks {
    pub readyForNextFrame: OniGeneralCallback,
}
#[test]
fn bindgen_test_layout_NiteHandTrackerCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<NiteHandTrackerCallbacks>(),
        8usize,
        concat!("Size of: ", stringify!(NiteHandTrackerCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteHandTrackerCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(NiteHandTrackerCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NiteHandTrackerCallbacks>())).readyForNextFrame as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteHandTrackerCallbacks),
            "::",
            stringify!(readyForNextFrame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteVersion {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub maintenance: ::std::os::raw::c_int,
    pub build: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NiteVersion() {
    assert_eq!(
        ::std::mem::size_of::<NiteVersion>(),
        16usize,
        concat!("Size of: ", stringify!(NiteVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<NiteVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(NiteVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).maintenance as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(maintenance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiteVersion>())).build as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NiteVersion),
            "::",
            stringify!(build)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiteHandTracker {
    _unused: [u8; 0],
}
pub type NiteHandTrackerHandle = *mut NiteHandTracker;
extern "C" {
    pub fn niteInitialize() -> NiteStatus;
}
extern "C" {
    pub fn niteShutdown();
}
extern "C" {
    pub fn niteGetVersion() -> NiteVersion;
}
extern "C" {
    pub fn niteInitializeUserTracker(arg1: *mut NiteUserTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteInitializeUserTrackerByDevice(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut NiteUserTrackerHandle,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteShutdownUserTracker(arg1: NiteUserTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteStartSkeletonTracking(arg1: NiteUserTrackerHandle, arg2: NiteUserId) -> NiteStatus;
}
extern "C" {
    pub fn niteStopSkeletonTracking(arg1: NiteUserTrackerHandle, arg2: NiteUserId);
}
extern "C" {
    pub fn niteIsSkeletonTracking(arg1: NiteUserTrackerHandle, arg2: NiteUserId) -> bool;
}
extern "C" {
    pub fn niteSetSkeletonSmoothing(arg1: NiteUserTrackerHandle, arg2: f32) -> NiteStatus;
}
extern "C" {
    pub fn niteGetSkeletonSmoothing(arg1: NiteUserTrackerHandle, arg2: *mut f32) -> NiteStatus;
}
extern "C" {
    pub fn niteStartPoseDetection(
        arg1: NiteUserTrackerHandle,
        arg2: NiteUserId,
        arg3: NitePoseType,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStopPoseDetection(arg1: NiteUserTrackerHandle, arg2: NiteUserId, arg3: NitePoseType);
}
extern "C" {
    pub fn niteStopAllPoseDetection(arg1: NiteUserTrackerHandle, arg2: NiteUserId);
}
extern "C" {
    pub fn niteRegisterUserTrackerCallbacks(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerCallbacks,
        arg3: *mut ::std::os::raw::c_void,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUnregisterUserTrackerCallbacks(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerCallbacks,
    );
}
extern "C" {
    pub fn niteReadUserTrackerFrame(
        arg1: NiteUserTrackerHandle,
        arg2: *mut *mut NiteUserTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUserTrackerFrameAddRef(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUserTrackerFrameRelease(
        arg1: NiteUserTrackerHandle,
        arg2: *mut NiteUserTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteInitializeHandTracker(arg1: *mut NiteHandTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteInitializeHandTrackerByDevice(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut NiteHandTrackerHandle,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteShutdownHandTracker(arg1: NiteHandTrackerHandle) -> NiteStatus;
}
extern "C" {
    pub fn niteStartHandTracking(
        arg1: NiteHandTrackerHandle,
        arg2: *const NitePoint3f,
        pNewHandId: *mut NiteHandId,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStopHandTracking(arg1: NiteHandTrackerHandle, arg2: NiteHandId);
}
extern "C" {
    pub fn niteStopAllHandTracking(arg1: NiteHandTrackerHandle);
}
extern "C" {
    pub fn niteSetHandSmoothingFactor(arg1: NiteHandTrackerHandle, arg2: f32) -> NiteStatus;
}
extern "C" {
    pub fn niteGetHandSmoothingFactor(arg1: NiteHandTrackerHandle, arg2: *mut f32) -> NiteStatus;
}
extern "C" {
    pub fn niteRegisterHandTrackerCallbacks(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerCallbacks,
        arg3: *mut ::std::os::raw::c_void,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteUnregisterHandTrackerCallbacks(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerCallbacks,
    );
}
extern "C" {
    pub fn niteReadHandTrackerFrame(
        arg1: NiteHandTrackerHandle,
        arg2: *mut *mut NiteHandTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteHandTrackerFrameAddRef(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteHandTrackerFrameRelease(
        arg1: NiteHandTrackerHandle,
        arg2: *mut NiteHandTrackerFrame,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStartGestureDetection(
        arg1: NiteHandTrackerHandle,
        arg2: NiteGestureType,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteStopGestureDetection(arg1: NiteHandTrackerHandle, arg2: NiteGestureType);
}
extern "C" {
    pub fn niteStopAllGestureDetection(arg1: NiteHandTrackerHandle);
}
extern "C" {
    pub fn niteConvertJointCoordinatesToDepth(
        userTracker: NiteUserTrackerHandle,
        x: f32,
        y: f32,
        z: f32,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteConvertDepthCoordinatesToJoint(
        userTracker: NiteUserTrackerHandle,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteConvertHandCoordinatesToDepth(
        handTracker: NiteHandTrackerHandle,
        x: f32,
        y: f32,
        z: f32,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}
extern "C" {
    pub fn niteConvertDepthCoordinatesToHand(
        handTracker: NiteHandTrackerHandle,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        pX: *mut f32,
        pY: *mut f32,
    ) -> NiteStatus;
}

#[doc = "This is the main object of the User Tracker algorithm.  It provides access to one half of the"]
#[doc = "algorithms provided by NiTE.  Scene segmentation, skeleton, floor plane detection, and pose"]
#[doc = "detection are all provided by this class."]
#[doc = ""]
#[doc = "The first purpose of the User Tracker algorithm is to find all of the active users in a specific scene."]
#[doc = "It individually tracks each human it finds, and provides the means to seperate their outline from"]
#[doc = "each other and from the background.  Once the scene has been segmented, the User Tracker is also used to initiate Skeleton"]
#[doc = "Tracking and Pose Detection algorithms."]
#[doc = ""]
#[doc = "Each user is provided an ID as they are detected.  The user ID remains constant as long as the"]
#[doc = "user remains in the frame.  If a user leaves the field of view of the camera, or tracking of that"]
#[doc = "user is otherwise lost, the user may have a different ID when he is detected again.  There is"]
#[doc = "currently no mechanism that provides persistant recognition of individuals when they are not being"]
#[doc = "actively tracking.  If this functionality is desired, it will need to be implimented at the"]
#[doc = "application level."]
#[doc = ""]
#[doc = "A listener class is provided to allow event based interaction with this algorithm."]
#[doc = ""]
#[doc = "@see UserMap for the output format of the User Tracker algorithm"]
#[doc = "@see UserData for additional data output by this format"]
#[doc = "@see Skeleton if you are also interested in tracking a user's skeleton"]
#[doc = "@see NiTE for a couple of static functions that must be run before User Tracker can be used"]
#[doc = "@see @ref HandTracker for Gesture and Hand tracking algorithms."]
#[repr(C)]
#[derive(Debug)]
pub struct nite_UserTracker {
    pub m_userTrackerHandle: NiteUserTrackerHandle,
}
#[repr(C)]
pub struct nite_UserTracker_NewFrameListener__bindgen_vtable(::std::os::raw::c_void);
#[doc = "This is a listener class that is used to react to events generated by the @ref UserTracker class."]
#[doc = ""]
#[doc = "To use this class, you must derive a class from it that implements the @ref onNewFrame() function.  This"]
#[doc = "is the function that will be called when an event is generated."]
#[doc = ""]
#[doc = "Create a new instance of your derived class.  Then, use the @ref UserTracker::addNewFrameListener()"]
#[doc = "function to add the listener to the @ref UserTracker.  When that @ref UserTracker generates an onNewFrame event, \\"]
#[doc = "the specified callback function will be called."]
#[doc = ""]
#[doc = "The onNewFrame event is currently the only event type that this listener is designed to work with."]
#[doc = ""]
#[doc = "@see @ref UserTracker for the source of this listener's events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_UserTracker_NewFrameListener {
    pub vtable_: *const nite_UserTracker_NewFrameListener__bindgen_vtable,
    pub m_userTrackerCallbacks: NiteUserTrackerCallbacks,
    pub m_pUserTracker: *mut nite_UserTracker,
}



#[test]
fn bindgen_test_layout_nite_UserTracker_NewFrameListener() {
    assert_eq!(
        ::std::mem::size_of::<nite_UserTracker_NewFrameListener>(),
        24usize,
        concat!("Size of: ", stringify!(nite_UserTracker_NewFrameListener))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_UserTracker_NewFrameListener>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nite_UserTracker_NewFrameListener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTracker_NewFrameListener>())).m_userTrackerCallbacks
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTracker_NewFrameListener),
            "::",
            stringify!(m_userTrackerCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTracker_NewFrameListener>())).m_pUserTracker as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTracker_NewFrameListener),
            "::",
            stringify!(m_pUserTracker)
        )
    );
}
#[test]
fn bindgen_test_layout_nite_UserTracker() {
    assert_eq!(
        ::std::mem::size_of::<nite_UserTracker>(),
        8usize,
        concat!("Size of: ", stringify!(nite_UserTracker))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_UserTracker>(),
        8usize,
        concat!("Alignment of ", stringify!(nite_UserTracker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_UserTracker>())).m_userTrackerHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_UserTracker),
            "::",
            stringify!(m_userTrackerHandle)
        )
    );
}
#[doc = "This is the main object of the Hand Tracker algorithm.  It (along with @ref UserTracker) is"]
#[doc = "one of two main classes in NiTE.  All NiTE algorithms are accessable through one of these two classes."]
#[doc = ""]
#[doc = "@ref HandTracker provides access to all algorithms relates to tracking individual hands, as well as"]
#[doc = "detecting gestures in the depthmap."]
#[doc = ""]
#[doc = "The core of the hand tracking is an algorithm that finds human hands in each from of the depthmap, and"]
#[doc = "reports the position of those hands in space.  This can be used for simple detection of higher level"]
#[doc = "gestures and implimentation of gesture based user interfaces.  Unlike full body tracking algorithms,"]
#[doc = "handpoint based tracking works on users that are sitting and does not require a full body be visible."]
#[doc = ""]
#[doc = "Gesture tracking is generally used to initiate hand tracking.  It allows detection of gestures in the"]
#[doc = "raw depth map, without requiring hand points (in contrast to higher-level gestures that might be"]
#[doc = "used to impliment a UI using handpoints).  These gestures can be located in space to provide a hint"]
#[doc = "to the hand tracking algorithm on where to start tracking."]
#[doc = ""]
#[doc = "The output of the HandTracker occurs one frame at a time.  For each input depth frame, a hand tracking frame"]
#[doc = "is output with hand positions, gesture positions, etc.  A listener class is provided that allows for event"]
#[doc = "driven reaction to each new frame as it arrives."]
#[doc = ""]
#[doc = "Note that creating a HandTracker requires a valid OpenNI 2.0 Device to be initialized in order to provide"]
#[doc = "depth information.  See the OpenNI 2.0 documenation for information on connecting a device and starting"]
#[doc = "the stream of depth maps that will drive this algorithm."]
#[doc = ""]
#[doc = "@see @ref UserTracker If you want to track full body motion, skeletons, find a floor plane, or detect poses."]
#[doc = "@see @ref NiTE For a list of static functions that must be used before using HandTracker"]
#[repr(C)]
#[derive(Debug)]
pub struct nite_HandTracker {
    pub m_handTrackerHandle: NiteHandTrackerHandle,
}
#[repr(C)]
pub struct nite_HandTracker_NewFrameListener__bindgen_vtable(::std::os::raw::c_void);
#[doc = "This is a listener class that is used to react to events generated by the @ref HandTracker class."]
#[doc = ""]
#[doc = "To use this class, you must derive a class from it that implements the @ref onNewFrame() function.  This"]
#[doc = "is the function that will be called when an event is generated."]
#[doc = ""]
#[doc = "Create a new instance of your derived class.  Then, use the @ref HandTracker::addNewFrameListener()"]
#[doc = "function to add the listener to the @ref HandTracker.  When that @ref HandTracker generates an onNewFrame event, \\"]
#[doc = "the specified callback function will be called."]
#[doc = ""]
#[doc = "The onNewFrame event is currently the only event type that this listener is designed to work with."]
#[doc = ""]
#[doc = "@see @ref HandTracker for the source of this listener's events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nite_HandTracker_NewFrameListener {
    pub vtable_: *const nite_HandTracker_NewFrameListener__bindgen_vtable,
    pub m_handTrackerCallbacks: NiteHandTrackerCallbacks,
    pub m_pHandTracker: *mut nite_HandTracker,
}
#[test]
fn bindgen_test_layout_nite_HandTracker_NewFrameListener() {
    assert_eq!(
        ::std::mem::size_of::<nite_HandTracker_NewFrameListener>(),
        24usize,
        concat!("Size of: ", stringify!(nite_HandTracker_NewFrameListener))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_HandTracker_NewFrameListener>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nite_HandTracker_NewFrameListener)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTracker_NewFrameListener>())).m_handTrackerCallbacks
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTracker_NewFrameListener),
            "::",
            stringify!(m_handTrackerCallbacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTracker_NewFrameListener>())).m_pHandTracker as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTracker_NewFrameListener),
            "::",
            stringify!(m_pHandTracker)
        )
    );
}
#[test]
fn bindgen_test_layout_nite_HandTracker() {
    assert_eq!(
        ::std::mem::size_of::<nite_HandTracker>(),
        8usize,
        concat!("Size of: ", stringify!(nite_HandTracker))
    );
    assert_eq!(
        ::std::mem::align_of::<nite_HandTracker>(),
        8usize,
        concat!("Alignment of ", stringify!(nite_HandTracker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nite_HandTracker>())).m_handTrackerHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nite_HandTracker),
            "::",
            stringify!(m_handTrackerHandle)
        )
    );
}
