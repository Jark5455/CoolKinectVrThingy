/* automatically generated by rust-bindgen 0.58.1 */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub const OniStatus_ONI_STATUS_OK: OniStatus = 0;
pub const OniStatus_ONI_STATUS_ERROR: OniStatus = 1;
pub const OniStatus_ONI_STATUS_NOT_IMPLEMENTED: OniStatus = 2;
pub const OniStatus_ONI_STATUS_NOT_SUPPORTED: OniStatus = 3;
pub const OniStatus_ONI_STATUS_BAD_PARAMETER: OniStatus = 4;
pub const OniStatus_ONI_STATUS_OUT_OF_FLOW: OniStatus = 5;
pub const OniStatus_ONI_STATUS_NO_DEVICE: OniStatus = 6;
pub const OniStatus_ONI_STATUS_TIME_OUT: OniStatus = 102;
#[doc = " Possible failure values"]
pub type OniStatus = ::std::os::raw::c_uint;
pub const OniSensorType_ONI_SENSOR_IR: OniSensorType = 1;
pub const OniSensorType_ONI_SENSOR_COLOR: OniSensorType = 2;
pub const OniSensorType_ONI_SENSOR_DEPTH: OniSensorType = 3;
#[doc = " The source of the stream"]
pub type OniSensorType = ::std::os::raw::c_uint;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_DEPTH_1_MM: OniPixelFormat = 100;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_DEPTH_100_UM: OniPixelFormat = 101;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_SHIFT_9_2: OniPixelFormat = 102;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_SHIFT_9_3: OniPixelFormat = 103;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_RGB888: OniPixelFormat = 200;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_YUV422: OniPixelFormat = 201;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_GRAY8: OniPixelFormat = 202;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_GRAY16: OniPixelFormat = 203;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_JPEG: OniPixelFormat = 204;
pub const OniPixelFormat_ONI_PIXEL_FORMAT_YUYV: OniPixelFormat = 205;
#[doc = " All available formats of the output of a stream"]
pub type OniPixelFormat = ::std::os::raw::c_uint;
pub const OniDeviceState_ONI_DEVICE_STATE_OK: OniDeviceState = 0;
pub const OniDeviceState_ONI_DEVICE_STATE_ERROR: OniDeviceState = 1;
pub const OniDeviceState_ONI_DEVICE_STATE_NOT_READY: OniDeviceState = 2;
pub const OniDeviceState_ONI_DEVICE_STATE_EOF: OniDeviceState = 3;
pub type OniDeviceState = ::std::os::raw::c_uint;
pub const OniImageRegistrationMode_ONI_IMAGE_REGISTRATION_OFF: OniImageRegistrationMode = 0;
pub const OniImageRegistrationMode_ONI_IMAGE_REGISTRATION_DEPTH_TO_COLOR: OniImageRegistrationMode =
    1;
pub type OniImageRegistrationMode = ::std::os::raw::c_uint;
#[doc = " Basic types"]
pub type OniBool = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniCallbackHandleImpl {
    _unused: [u8; 0],
}
pub type OniCallbackHandle = *mut OniCallbackHandleImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniVersion {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub maintenance: ::std::os::raw::c_int,
    pub build: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OniVersion() {
    assert_eq!(
        ::std::mem::size_of::<OniVersion>(),
        16usize,
        concat!("Size of: ", stringify!(OniVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<OniVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(OniVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVersion>())).minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVersion>())).maintenance as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVersion),
            "::",
            stringify!(maintenance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVersion>())).build as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVersion),
            "::",
            stringify!(build)
        )
    );
}
pub type OniHardwareVersion = ::std::os::raw::c_int;
#[doc = " Description of the output: format and resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniVideoMode {
    pub pixelFormat: OniPixelFormat,
    pub resolutionX: ::std::os::raw::c_int,
    pub resolutionY: ::std::os::raw::c_int,
    pub fps: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OniVideoMode() {
    assert_eq!(
        ::std::mem::size_of::<OniVideoMode>(),
        16usize,
        concat!("Size of: ", stringify!(OniVideoMode))
    );
    assert_eq!(
        ::std::mem::align_of::<OniVideoMode>(),
        4usize,
        concat!("Alignment of ", stringify!(OniVideoMode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVideoMode>())).pixelFormat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVideoMode),
            "::",
            stringify!(pixelFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVideoMode>())).resolutionX as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVideoMode),
            "::",
            stringify!(resolutionX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVideoMode>())).resolutionY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVideoMode),
            "::",
            stringify!(resolutionY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniVideoMode>())).fps as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OniVideoMode),
            "::",
            stringify!(fps)
        )
    );
}
#[doc = " List of supported video modes by a specific source"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniSensorInfo {
    pub sensorType: OniSensorType,
    pub numSupportedVideoModes: ::std::os::raw::c_int,
    pub pSupportedVideoModes: *mut OniVideoMode,
}
#[test]
fn bindgen_test_layout_OniSensorInfo() {
    assert_eq!(
        ::std::mem::size_of::<OniSensorInfo>(),
        16usize,
        concat!("Size of: ", stringify!(OniSensorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OniSensorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OniSensorInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniSensorInfo>())).sensorType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniSensorInfo),
            "::",
            stringify!(sensorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OniSensorInfo>())).numSupportedVideoModes as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OniSensorInfo),
            "::",
            stringify!(numSupportedVideoModes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OniSensorInfo>())).pSupportedVideoModes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OniSensorInfo),
            "::",
            stringify!(pSupportedVideoModes)
        )
    );
}
#[doc = " Basic description of a device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OniDeviceInfo {
    pub uri: [::std::os::raw::c_char; 256usize],
    pub vendor: [::std::os::raw::c_char; 256usize],
    pub name: [::std::os::raw::c_char; 256usize],
    pub usbVendorId: u16,
    pub usbProductId: u16,
}
#[test]
fn bindgen_test_layout_OniDeviceInfo() {
    assert_eq!(
        ::std::mem::size_of::<OniDeviceInfo>(),
        772usize,
        concat!("Size of: ", stringify!(OniDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OniDeviceInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(OniDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniDeviceInfo>())).uri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceInfo),
            "::",
            stringify!(uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniDeviceInfo>())).vendor as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceInfo),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniDeviceInfo>())).name as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniDeviceInfo>())).usbVendorId as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceInfo),
            "::",
            stringify!(usbVendorId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniDeviceInfo>())).usbProductId as *const _ as usize },
        770usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceInfo),
            "::",
            stringify!(usbProductId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OniDevice {
    _unused: [u8; 0],
}
pub type OniDeviceHandle = *mut _OniDevice;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OniStream {
    _unused: [u8; 0],
}
pub type OniStreamHandle = *mut _OniStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OniRecorder {
    _unused: [u8; 0],
}
pub type OniRecorderHandle = *mut _OniRecorder;
#[doc = " All information of the current frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniFrame {
    pub dataSize: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_void,
    pub sensorType: OniSensorType,
    pub timestamp: u64,
    pub frameIndex: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub videoMode: OniVideoMode,
    pub croppingEnabled: OniBool,
    pub cropOriginX: ::std::os::raw::c_int,
    pub cropOriginY: ::std::os::raw::c_int,
    pub stride: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OniFrame() {
    assert_eq!(
        ::std::mem::size_of::<OniFrame>(),
        80usize,
        concat!("Size of: ", stringify!(OniFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<OniFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(OniFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).dataSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).sensorType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(sensorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).timestamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).frameIndex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(frameIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).width as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).height as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).videoMode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(videoMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).croppingEnabled as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(croppingEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).cropOriginX as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(cropOriginX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).cropOriginY as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(cropOriginY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniFrame>())).stride as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OniFrame),
            "::",
            stringify!(stride)
        )
    );
}
pub type OniNewFrameCallback = ::std::option::Option<
    unsafe extern "C" fn(stream: OniStreamHandle, pCookie: *mut ::std::os::raw::c_void),
>;
pub type OniGeneralCallback =
    ::std::option::Option<unsafe extern "C" fn(pCookie: *mut ::std::os::raw::c_void)>;
pub type OniDeviceInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(pInfo: *const OniDeviceInfo, pCookie: *mut ::std::os::raw::c_void),
>;
pub type OniDeviceStateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        pInfo: *const OniDeviceInfo,
        deviceState: OniDeviceState,
        pCookie: *mut ::std::os::raw::c_void,
    ),
>;
pub type OniFrameAllocBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(
        size: ::std::os::raw::c_int,
        pCookie: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type OniFrameFreeBufferCallback = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, pCookie: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniDeviceCallbacks {
    pub deviceConnected: OniDeviceInfoCallback,
    pub deviceDisconnected: OniDeviceInfoCallback,
    pub deviceStateChanged: OniDeviceStateCallback,
}
#[test]
fn bindgen_test_layout_OniDeviceCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<OniDeviceCallbacks>(),
        24usize,
        concat!("Size of: ", stringify!(OniDeviceCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<OniDeviceCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(OniDeviceCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OniDeviceCallbacks>())).deviceConnected as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceCallbacks),
            "::",
            stringify!(deviceConnected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OniDeviceCallbacks>())).deviceDisconnected as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceCallbacks),
            "::",
            stringify!(deviceDisconnected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OniDeviceCallbacks>())).deviceStateChanged as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OniDeviceCallbacks),
            "::",
            stringify!(deviceStateChanged)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniCropping {
    pub enabled: ::std::os::raw::c_int,
    pub originX: ::std::os::raw::c_int,
    pub originY: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OniCropping() {
    assert_eq!(
        ::std::mem::size_of::<OniCropping>(),
        20usize,
        concat!("Size of: ", stringify!(OniCropping))
    );
    assert_eq!(
        ::std::mem::align_of::<OniCropping>(),
        4usize,
        concat!("Alignment of ", stringify!(OniCropping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniCropping>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniCropping),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniCropping>())).originX as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OniCropping),
            "::",
            stringify!(originX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniCropping>())).originY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OniCropping),
            "::",
            stringify!(originY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniCropping>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OniCropping),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniCropping>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OniCropping),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "Pixel type used to store depth images."]
pub type OniDepthPixel = u16;
#[doc = "Pixel type used to store 16-bit grayscale images"]
pub type OniGrayscale16Pixel = u16;
#[doc = "Pixel type used to store 8-bit grayscale/bayer images"]
pub type OniGrayscale8Pixel = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniRGB888Pixel {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}
#[test]
fn bindgen_test_layout_OniRGB888Pixel() {
    assert_eq!(
        ::std::mem::size_of::<OniRGB888Pixel>(),
        3usize,
        concat!("Size of: ", stringify!(OniRGB888Pixel))
    );
    assert_eq!(
        ::std::mem::align_of::<OniRGB888Pixel>(),
        1usize,
        concat!("Alignment of ", stringify!(OniRGB888Pixel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniRGB888Pixel>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniRGB888Pixel),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniRGB888Pixel>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(OniRGB888Pixel),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniRGB888Pixel>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OniRGB888Pixel),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniYUV422DoublePixel {
    pub u: u8,
    pub y1: u8,
    pub v: u8,
    pub y2: u8,
}
#[test]
fn bindgen_test_layout_OniYUV422DoublePixel() {
    assert_eq!(
        ::std::mem::size_of::<OniYUV422DoublePixel>(),
        4usize,
        concat!("Size of: ", stringify!(OniYUV422DoublePixel))
    );
    assert_eq!(
        ::std::mem::align_of::<OniYUV422DoublePixel>(),
        1usize,
        concat!("Alignment of ", stringify!(OniYUV422DoublePixel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniYUV422DoublePixel>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniYUV422DoublePixel),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniYUV422DoublePixel>())).y1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(OniYUV422DoublePixel),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniYUV422DoublePixel>())).v as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OniYUV422DoublePixel),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniYUV422DoublePixel>())).y2 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(OniYUV422DoublePixel),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OniSeek {
    pub frameIndex: ::std::os::raw::c_int,
    pub stream: OniStreamHandle,
}
#[test]
fn bindgen_test_layout_OniSeek() {
    assert_eq!(
        ::std::mem::size_of::<OniSeek>(),
        16usize,
        concat!("Size of: ", stringify!(OniSeek))
    );
    assert_eq!(
        ::std::mem::align_of::<OniSeek>(),
        8usize,
        concat!("Alignment of ", stringify!(OniSeek))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniSeek>())).frameIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OniSeek),
            "::",
            stringify!(frameIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OniSeek>())).stream as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OniSeek),
            "::",
            stringify!(stream)
        )
    );
}
extern "C" {
    #[doc = "  Initialize OpenNI2. Use ONI_API_VERSION as the version."]
    pub fn oniInitialize(apiVersion: ::std::os::raw::c_int) -> OniStatus;
}
extern "C" {
    #[doc = "  Shutdown OpenNI2"]
    pub fn oniShutdown();
}
extern "C" {
    #[doc = " Get the list of currently connected device."]
    #[doc = " Each device is represented by its OniDeviceInfo."]
    #[doc = " pDevices will be allocated inside."]
    pub fn oniGetDeviceList(
        pDevices: *mut *mut OniDeviceInfo,
        pNumDevices: *mut ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Release previously allocated device list"]
    pub fn oniReleaseDeviceList(pDevices: *mut OniDeviceInfo) -> OniStatus;
}
extern "C" {
    pub fn oniRegisterDeviceCallbacks(
        pCallbacks: *mut OniDeviceCallbacks,
        pCookie: *mut ::std::os::raw::c_void,
        pHandle: *mut OniCallbackHandle,
    ) -> OniStatus;
}
extern "C" {
    pub fn oniUnregisterDeviceCallbacks(handle: OniCallbackHandle);
}
extern "C" {
    #[doc = " Wait for any of the streams to have a new frame"]
    pub fn oniWaitForAnyStream(
        pStreams: *mut OniStreamHandle,
        numStreams: ::std::os::raw::c_int,
        pStreamIndex: *mut ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Get the current version of OpenNI2"]
    pub fn oniGetVersion() -> OniVersion;
}
extern "C" {
    #[doc = " Translate from format to number of bytes per pixel. Will return 0 for formats in which the number of bytes per pixel isn't fixed."]
    pub fn oniFormatBytesPerPixel(format: OniPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get internal error"]
    pub fn oniGetExtendedError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Open a device. Uri can be taken from the matching OniDeviceInfo."]
    pub fn oniDeviceOpen(
        uri: *const ::std::os::raw::c_char,
        pDevice: *mut OniDeviceHandle,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Close a device"]
    pub fn oniDeviceClose(device: OniDeviceHandle) -> OniStatus;
}
extern "C" {
    #[doc = " Get the possible configurations available for a specific source, or NULL if the source does not exist."]
    pub fn oniDeviceGetSensorInfo(
        device: OniDeviceHandle,
        sensorType: OniSensorType,
    ) -> *const OniSensorInfo;
}
extern "C" {
    #[doc = " Get the OniDeviceInfo of a certain device."]
    pub fn oniDeviceGetInfo(device: OniDeviceHandle, pInfo: *mut OniDeviceInfo) -> OniStatus;
}
extern "C" {
    #[doc = " Create a new stream in the device. The stream will originate from the source."]
    pub fn oniDeviceCreateStream(
        device: OniDeviceHandle,
        sensorType: OniSensorType,
        pStream: *mut OniStreamHandle,
    ) -> OniStatus;
}
extern "C" {
    pub fn oniDeviceEnableDepthColorSync(device: OniDeviceHandle) -> OniStatus;
}
extern "C" {
    pub fn oniDeviceDisableDepthColorSync(device: OniDeviceHandle);
}
extern "C" {
    pub fn oniDeviceGetDepthColorSyncEnabled(device: OniDeviceHandle) -> OniBool;
}
extern "C" {
    #[doc = " Set property in the device. Use the properties listed in OniTypes.h: ONI_DEVICE_PROPERTY_..., or specific ones supplied by the device."]
    pub fn oniDeviceSetProperty(
        device: OniDeviceHandle,
        propertyId: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        dataSize: ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Get property in the device. Use the properties listed in OniTypes.h: ONI_DEVICE_PROPERTY_..., or specific ones supplied by the device."]
    pub fn oniDeviceGetProperty(
        device: OniDeviceHandle,
        propertyId: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        pDataSize: *mut ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Check if the property is supported by the device. Use the properties listed in OniTypes.h: ONI_DEVICE_PROPERTY_..., or specific ones supplied by the device."]
    pub fn oniDeviceIsPropertySupported(
        device: OniDeviceHandle,
        propertyId: ::std::os::raw::c_int,
    ) -> OniBool;
}
extern "C" {
    #[doc = " Invoke an internal functionality of the device."]
    pub fn oniDeviceInvoke(
        device: OniDeviceHandle,
        commandId: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        dataSize: ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Check if a command is supported, for invoke"]
    pub fn oniDeviceIsCommandSupported(
        device: OniDeviceHandle,
        commandId: ::std::os::raw::c_int,
    ) -> OniBool;
}
extern "C" {
    pub fn oniDeviceIsImageRegistrationModeSupported(
        device: OniDeviceHandle,
        mode: OniImageRegistrationMode,
    ) -> OniBool;
}
extern "C" {
    #[doc = " Destroy an existing stream"]
    pub fn oniStreamDestroy(stream: OniStreamHandle);
}
extern "C" {
    #[doc = " Get the OniSensorInfo of the certain stream."]
    pub fn oniStreamGetSensorInfo(stream: OniStreamHandle) -> *const OniSensorInfo;
}
extern "C" {
    #[doc = " Start generating data from the stream."]
    pub fn oniStreamStart(stream: OniStreamHandle) -> OniStatus;
}
extern "C" {
    #[doc = " Stop generating data from the stream."]
    pub fn oniStreamStop(stream: OniStreamHandle);
}
extern "C" {
    #[doc = " Get the next frame from the stream. This function is blocking until there is a new frame from the stream. For timeout, use oniWaitForStreams() first"]
    pub fn oniStreamReadFrame(stream: OniStreamHandle, pFrame: *mut *mut OniFrame) -> OniStatus;
}
extern "C" {
    #[doc = " Register a callback to when the stream has a new frame."]
    pub fn oniStreamRegisterNewFrameCallback(
        stream: OniStreamHandle,
        handler: OniNewFrameCallback,
        pCookie: *mut ::std::os::raw::c_void,
        pHandle: *mut OniCallbackHandle,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Unregister a previously registered callback to when the stream has a new frame."]
    pub fn oniStreamUnregisterNewFrameCallback(stream: OniStreamHandle, handle: OniCallbackHandle);
}
extern "C" {
    #[doc = " Set property in the stream. Use the properties listed in OniTypes.h: ONI_STREAM_PROPERTY_..., or specific ones supplied by the device for its streams."]
    pub fn oniStreamSetProperty(
        stream: OniStreamHandle,
        propertyId: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        dataSize: ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Get property in the stream. Use the properties listed in OniTypes.h: ONI_STREAM_PROPERTY_..., or specific ones supplied by the device for its streams."]
    pub fn oniStreamGetProperty(
        stream: OniStreamHandle,
        propertyId: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        pDataSize: *mut ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Check if the property is supported the stream. Use the properties listed in OniTypes.h: ONI_STREAM_PROPERTY_..., or specific ones supplied by the device for its streams."]
    pub fn oniStreamIsPropertySupported(
        stream: OniStreamHandle,
        propertyId: ::std::os::raw::c_int,
    ) -> OniBool;
}
extern "C" {
    #[doc = " Invoke an internal functionality of the stream."]
    pub fn oniStreamInvoke(
        stream: OniStreamHandle,
        commandId: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        dataSize: ::std::os::raw::c_int,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Check if a command is supported, for invoke"]
    pub fn oniStreamIsCommandSupported(
        stream: OniStreamHandle,
        commandId: ::std::os::raw::c_int,
    ) -> OniBool;
}
extern "C" {
    #[doc = " Sets the stream buffer allocation functions. Note that this function may only be called while stream is not started."]
    pub fn oniStreamSetFrameBuffersAllocator(
        stream: OniStreamHandle,
        alloc: OniFrameAllocBufferCallback,
        free: OniFrameFreeBufferCallback,
        pCookie: *mut ::std::os::raw::c_void,
    ) -> OniStatus;
}
extern "C" {
    #[doc = ""]
    #[doc = "** Mark another user of the frame. */"]
    pub fn oniFrameAddRef(pFrame: *mut OniFrame);
}
extern "C" {
    #[doc = " Mark that the frame is no longer needed."]
    pub fn oniFrameRelease(pFrame: *mut OniFrame);
}
extern "C" {
    #[doc = " Creates a recorder that records to a file."]
    #[doc = " @param\t[in]\tfileName\tThe name of the file that will contain the recording."]
    #[doc = " @param\t[out]\tpRecorder\tPoints to the handle to the newly created recorder."]
    #[doc = " @retval ONI_STATUS_OK Upon successful completion."]
    #[doc = " @retval ONI_STATUS_ERROR Upon any kind of failure."]
    pub fn oniCreateRecorder(
        fileName: *const ::std::os::raw::c_char,
        pRecorder: *mut OniRecorderHandle,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Attaches a stream to a recorder. The amount of attached streams is virtually"]
    #[doc = " infinite. You cannot attach a stream after you have started a recording, if"]
    #[doc = " you do: an error will be returned by oniRecorderAttachStream."]
    #[doc = " @param\t[in]\trecorder\t\t\t\tThe handle to the recorder."]
    #[doc = " @param\t[in]\tstream\t\t\t\t\tThe handle to the stream."]
    #[doc = " @param\t[in]\tallowLossyCompression\tAllows/denies lossy compression"]
    #[doc = " @retval ONI_STATUS_OK Upon successful completion."]
    #[doc = " @retval ONI_STATUS_ERROR Upon any kind of failure."]
    pub fn oniRecorderAttachStream(
        recorder: OniRecorderHandle,
        stream: OniStreamHandle,
        allowLossyCompression: OniBool,
    ) -> OniStatus;
}
extern "C" {
    #[doc = " Starts recording. There must be at least one stream attached to the recorder,"]
    #[doc = " if not: oniRecorderStart will return an error."]
    #[doc = " @param[in] recorder The handle to the recorder."]
    #[doc = " @retval ONI_STATUS_OK Upon successful completion."]
    #[doc = " @retval ONI_STATUS_ERROR Upon any kind of failure."]
    pub fn oniRecorderStart(recorder: OniRecorderHandle) -> OniStatus;
}
extern "C" {
    #[doc = " Stops recording. You can resume recording via oniRecorderStart."]
    #[doc = " @param[in] recorder The handle to the recorder."]
    #[doc = " @retval ONI_STATUS_OK Upon successful completion."]
    #[doc = " @retval ONI_STATUS_ERROR Upon any kind of failure."]
    pub fn oniRecorderStop(recorder: OniRecorderHandle);
}
extern "C" {
    #[doc = " Stops recording if needed, and destroys a recorder."]
    #[doc = " @param\t[in,out]\trecorder\tThe handle to the recorder, the handle will be"]
    #[doc = "\t\t\t\t\t\t\t\t\tinvalidated (nullified) when the function returns."]
    #[doc = " @retval ONI_STATUS_OK Upon successful completion."]
    #[doc = " @retval ONI_STATUS_ERROR Upon any kind of failure."]
    pub fn oniRecorderDestroy(pRecorder: *mut OniRecorderHandle) -> OniStatus;
}
extern "C" {
    pub fn oniCoordinateConverterDepthToWorld(
        depthStream: OniStreamHandle,
        depthX: f32,
        depthY: f32,
        depthZ: f32,
        pWorldX: *mut f32,
        pWorldY: *mut f32,
        pWorldZ: *mut f32,
    ) -> OniStatus;
}
extern "C" {
    pub fn oniCoordinateConverterWorldToDepth(
        depthStream: OniStreamHandle,
        worldX: f32,
        worldY: f32,
        worldZ: f32,
        pDepthX: *mut f32,
        pDepthY: *mut f32,
        pDepthZ: *mut f32,
    ) -> OniStatus;
}
extern "C" {
    pub fn oniCoordinateConverterDepthToColor(
        depthStream: OniStreamHandle,
        colorStream: OniStreamHandle,
        depthX: ::std::os::raw::c_int,
        depthY: ::std::os::raw::c_int,
        depthZ: OniDepthPixel,
        pColorX: *mut ::std::os::raw::c_int,
        pColorY: *mut ::std::os::raw::c_int,
    ) -> OniStatus;
}

pub struct Device {
    m_pPlaybackControl: *mut PlaybackControl,
    m_device: OniDeviceHandle,
    m_deviceInfo: OniDeviceInfo,
    m_aSensorInfo: [SensorInfo; 10],

    m_isOwner: bool
}

pub struct PlaybackControl {
    m_pDevice: *mut Device
}

pub struct SensorInfo {
    m_pInfo: *const OniSensorInfo,
}
